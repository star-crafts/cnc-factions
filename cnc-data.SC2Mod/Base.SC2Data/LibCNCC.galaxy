include "TriggerLibs/NativeLib"

include "LibCNCC_h"

//--------------------------------------------------------------------------------------------------
// Library: CNC
//--------------------------------------------------------------------------------------------------
// External Library Initialization
void libCNCC_InitLibraries () {
    libNtve_InitVariables();
}

// Variable Initialization
bool libCNCC_InitVariables_completed = false;

void libCNCC_InitVariables () {
    int init_i;
    int init_j;

    if (libCNCC_InitVariables_completed) {
        return;
    }

    libCNCC_InitVariables_completed = true;

    for (init_i = 0; init_i <= libCNCC_gv_beaconGroups; init_i += 1) {
        libCNCC_gv_watchTypes[init_i] = "";
    }
    for (init_i = 0; init_i <= 15; init_i += 1) {
        for (init_j = 0; init_j <= libCNCC_gv_beaconGroups; init_j += 1) {
            libCNCC_gv_productionUnits[init_i][init_j] = UnitGroupEmpty();
        }
    }
    for (init_i = 0; init_i <= libCNCC_gv_beaconGroups; init_i += 1) {
        libCNCC_gv_labels[init_i] = c_invalidDialogControlId;
    }
    for (init_i = 0; init_i <= libCNCC_gv_beaconGroups; init_i += 1) {
        libCNCC_gv_buttons[init_i] = c_invalidDialogControlId;
    }
    libCNCC_gv_aF_SlimUI_PlayerGroup = PlayerGroupEmpty();
    libCNCC_gv_alliancepanel = c_invalidDialogControlId;
}

// Presets
// Functions
void libCNCC_gf_RegisterUnit (unit lp_unit, int lp_player) {
    // Automatic Variable Declarations
    // Implementation
    if ((UnitHasBehavior2(lp_unit, "CNCTabConstruction") == true)) {
        libCNCC_gf_AddproductionUnit(lp_unit, lp_player, 1);
    }

    if ((UnitHasBehavior2(lp_unit, "CNCTabEconomy") == true)) {
        libCNCC_gf_AddproductionUnit(lp_unit, lp_player, 2);
    }

    if ((UnitHasBehavior2(lp_unit, "CNCTabInfantry") == true)) {
        libCNCC_gf_AddproductionUnit(lp_unit, lp_player, 3);
    }

    if ((UnitHasBehavior2(lp_unit, "CNCTabVehicles") == true)) {
        libCNCC_gf_AddproductionUnit(lp_unit, lp_player, 4);
    }

    if ((UnitHasBehavior2(lp_unit, "CNCTabAirforce") == true)) {
        libCNCC_gf_AddproductionUnit(lp_unit, lp_player, 5);
    }

}

void libCNCC_gf_UnRegisterUnit (unit lp_unit, int lp_player) {
    // Automatic Variable Declarations
    // Implementation
    if ((UnitHasBehavior2(lp_unit, "CNCTabConstruction") == true)) {
        libCNCC_gf_DeleteProductionUnit(lp_unit, lp_player, 1);
    }

    if ((UnitHasBehavior2(lp_unit, "CNCTabEconomy") == true)) {
        libCNCC_gf_DeleteProductionUnit(lp_unit, lp_player, 2);
    }

    if ((UnitHasBehavior2(lp_unit, "CNCTabInfantry") == true)) {
        libCNCC_gf_DeleteProductionUnit(lp_unit, lp_player, 3);
    }

    if ((UnitHasBehavior2(lp_unit, "CNCTabVehicles") == true)) {
        libCNCC_gf_DeleteProductionUnit(lp_unit, lp_player, 4);
    }

    if ((UnitHasBehavior2(lp_unit, "CNCTabAirforce") == true)) {
        libCNCC_gf_DeleteProductionUnit(lp_unit, lp_player, 5);
    }

}

void libCNCC_gf_AddproductionUnit (unit lp_unit, int lp_player, int lp_productionTabIndex) {
    // Variable Declarations
    int lv_living;

    // Automatic Variable Declarations
    // Variable Initialization

    // Implementation
    UnitGroupAdd(libCNCC_gv_productionUnits[lp_player][lp_productionTabIndex], lp_unit);
    lv_living = UnitGroupCount(libCNCC_gv_productionUnits[lp_player][lp_productionTabIndex], c_unitCountAlive);
    libNtve_gf_SetDialogItemText(libCNCC_gv_labels[lp_productionTabIndex], IntToText(lv_living), PlayerGroupSingle(lp_player));
    if ((lv_living == 1)) {
        DialogControlSetEnabled(libCNCC_gv_buttons[lp_productionTabIndex], PlayerGroupSingle(lp_player), true);
    }

}

void libCNCC_gf_DeleteProductionUnit (unit lp_unit, int lp_player, int lp_productionTabIndex) {
    // Variable Declarations
    int lv_living;

    // Automatic Variable Declarations
    // Variable Initialization

    // Implementation
    UnitGroupRemove(libCNCC_gv_productionUnits[lp_player][lp_productionTabIndex], lp_unit);
    lv_living = UnitGroupCount(libCNCC_gv_productionUnits[lp_player][lp_productionTabIndex], c_unitCountAlive);
    libNtve_gf_SetDialogItemText(libCNCC_gv_labels[lp_productionTabIndex], IntToText(lv_living), PlayerGroupSingle(lp_player));
    if ((lv_living == 0)) {
        DialogControlSetEnabled(libCNCC_gv_buttons[lp_productionTabIndex], PlayerGroupSingle(lp_player), false);
    }

}

void libCNCC_gf_AttachUnitModelToUnit (unit lp_attachmentUnit, unit lp_targetUnit, string lp_attachPont2, fixed lp_xOffset, fixed lp_yOffset, fixed lp_zOffset, string lp_facingAdjustment) {
    // Automatic Variable Declarations
    // Implementation
    libNtve_gf_SendActorMessageToUnit(lp_attachmentUnit, "RefSet ::global.XanthosNewPart ::Self");
    libNtve_gf_SendActorMessageToUnit(lp_targetUnit, "RefSet ::global.XanthosBody ::Self");
    libNtve_gf_SendActorMessageToUnit(lp_attachmentUnit, "RefSet ::actor.MainBody ::global.XanthosBody");
    libNtve_gf_SendActorMessageToUnit(lp_attachmentUnit, "Signal BaselineHook");
    libNtve_gf_SendActorMessageToUnit(lp_targetUnit, (("AttachOffset ::global.XanthosNewPart {" + lp_attachPont2 + "} " + FixedToString(lp_xOffset, c_fixedPrecisionAny) + "," + FixedToString(lp_yOffset, c_fixedPrecisionAny) + "," + FixedToString(lp_zOffset, c_fixedPrecisionAny) + " {} {" + (lp_facingAdjustment) + "}")));
    ActorSend(ActorFromActor(libNtve_gf_MainActorofUnit(lp_targetUnit), "XanthosPartList"), "ListAdd ::global.XanthosNewPart");
}

void libCNCC_gf_Theplanetakesoff (unit lp_airplane) {
    // Automatic Variable Declarations
    // Implementation
    UnitBehaviorRemove(lp_airplane, "Airportlanded", 1);
    UnitBehaviorRemove(lp_airplane, "Notifyairportaftertakeofforexplosion", 1);
    UnitBehaviorRemove(lp_airplane, "Airportcirclingprohibitedforaperiodoftime", 1);
    UnitCreateEffectUnit(lp_airplane, "AircraftTraverseTrackingAirport", lp_airplane);
    UnitBehaviorRemove(lp_airplane, "Aircraftreversesurveillanceoftheairport", 1);
    UnitBehaviorAdd(lp_airplane, "Airporttakingoff", lp_airplane, 1);
    if ((UnitGetType(lp_airplane) == "AlliedCenturyBomber")) {
        UnitSetHeight(lp_airplane, 5.0, 1.6);
        UnitBehaviorSetDuration(lp_airplane, "Airporttakingoff", 1.6);
    }
    else {
        UnitSetHeight(lp_airplane, 5.0, 0.75);
        UnitBehaviorSetDuration(lp_airplane, "Airporttakingoff", 0.75);
    }
}

void libCNCC_gf_SearchForAirportandLockit (unit lp_airplane, unit lp_searchTarget, int lp_radius, bool lp_skipOccupied) {
    // Variable Declarations
    unit lv_searchTarget;
    unit lv_airport;
    unit lv_airplane;
    int lv_useslot;
    int lv_radius;
    unitgroup lv_priority1;
    unitgroup lv_priority2;
    unitgroup lv_priority3;
    string lv_uD;
    point lv_landingpoint;

    // Automatic Variable Declarations
    unitgroup auto711BC669_g;
    int auto711BC669_u;
    unit auto711BC669_var;

    // Variable Initialization
    lv_searchTarget = lp_searchTarget;
    lv_airplane = lp_airplane;
    lv_radius = lp_radius;
    lv_priority1 = UnitGroupEmpty();
    lv_priority2 = UnitGroupEmpty();
    lv_priority3 = UnitGroupEmpty();

    // Implementation
    if ((lv_radius == 0)) {
        lv_radius = 999;
    }

    if ((lv_searchTarget == null)) {
        lv_searchTarget = lv_airplane;
    }

    auto711BC669_g = UnitGroup(null, UnitGetOwner(lv_airplane), RegionCircle(UnitGetPosition(lv_searchTarget), lv_radius), UnitFilter(0, 0, (1 << c_targetFilterMissile), (1 << (c_targetFilterUnderConstruction - 32)) | (1 << (c_targetFilterDead - 32)) | (1 << (c_targetFilterHidden - 32))), 0);
    auto711BC669_u = UnitGroupCount(auto711BC669_g, c_unitCountAll);
    for (;; auto711BC669_u -= 1) {
        auto711BC669_var = UnitGroupUnitFromEnd(auto711BC669_g, auto711BC669_u);
        if (auto711BC669_var == null) { break; }
        if ((UnitHasBehavior2(auto711BC669_var, "AircraftAirportParkingAircraftTracking") == true)) {
            if ((UnitHasBehavior2(auto711BC669_var, "Docked") == false)) {
                if ((UnitHasBehavior2(auto711BC669_var, "LockedLandingPad") == false)) {
                    UnitGroupAdd(lv_priority1, auto711BC669_var);
                }
                else {
                    UnitGroupAdd(lv_priority2, auto711BC669_var);
                }
            }
            else {
                if ((lp_skipOccupied == false)) {
                    UnitGroupAdd(lv_priority3, auto711BC669_var);
                }

            }
        }

    }
    if ((UnitGroupCount(lv_priority1, c_unitCountAlive) > 0)) {
        lv_airport = UnitGroupClosestToPoint(lv_priority1, UnitGetPosition(lv_searchTarget));
    }
    else {
        if ((UnitGroupCount(lv_priority2, c_unitCountAlive) > 0)) {
            lv_airport = UnitGroupClosestToPoint(lv_priority2, UnitGetPosition(lv_searchTarget));
        }
        else {
            if ((UnitGroupCount(lv_priority3, c_unitCountAlive) > 0)) {
                lv_airport = UnitGroupClosestToPoint(lv_priority3, UnitGetPosition(lv_searchTarget));
            }

        }
    }
    if ((lv_airport != null)) {
        libCNCC_gf_TargetAirport(lv_airplane, lv_airport);
    }

}

void libCNCC_gf_TargetAirport (unit lp_airplane, unit lp_airport) {
    // Variable Declarations
    unit lv_airport;
    unit lv_airplane;
    int lv_useslot;
    point lv_landingpoint;

    // Automatic Variable Declarations
    // Variable Initialization
    lv_airport = lp_airport;
    lv_airplane = lp_airplane;

    // Implementation
    lv_landingpoint = PointWithOffsetPolar(PointWithOffsetPolar(UnitGetPosition(lp_airport), UnitGetCustomValue(lv_airport, 1), (-45.0 + UnitGetFacing(lv_airport))), UnitGetCustomValue(lv_airport, 2), (UnitGetFacing(lv_airport) + 45.0));
    UnitIssueOrder(lp_airplane, OrderTargetingPoint(AbilityCommand("VS_ReturnToAirport", 0), lv_landingpoint), c_orderQueueReplace);
    DataTableSetUnit(true, ("TARGETAIRPORT" + IntToString(UnitGetTag(lv_airplane))), lv_airport);
    UnitBehaviorAdd(lv_airport, "LockedLandingPad", lv_airplane, 1);
}

point libCNCC_gf_Circledunitsturntoacquisitionpoint (unit lp_attackingunit, point lp_locationoftheattackedunit, bool lp_whetherthetargetpointistotheleftoftheunit) {
    // Variable Declarations
    point[37] lv_circlepoint;
    int lv_a;
    int lv_b;
    fixed lv_distance;
    point lv_closestpoint;
    fixed lv_anglefromcentertonearestpoint;
    fixed lv_theproperangle;
    point lv_finalpoint;

    // Automatic Variable Declarations
    // Variable Initialization
    lv_distance = 200.0;

    // Implementation
    lv_anglefromcentertonearestpoint = AngleBetweenPoints(lp_locationoftheattackedunit, UnitGetPosition(lp_attackingunit));
    if (((TechTreeUnitCount(1, "Nexus", c_techCountCompleteOnly) == 1) && (lv_anglefromcentertonearestpoint < -150.0) && (lv_anglefromcentertonearestpoint > -180.0))) {
        lv_theproperangle = (180.0 - (lv_anglefromcentertonearestpoint - -180.0));
    }
    else {
        if ((lp_whetherthetargetpointistotheleftoftheunit == false)) {
            lv_theproperangle = (lv_anglefromcentertonearestpoint - 30.0);
        }
        else {
            lv_theproperangle = (lv_anglefromcentertonearestpoint + 30.0);
        }
    }
    lv_finalpoint = PointWithOffsetPolar(lp_locationoftheattackedunit, 7.0, lv_theproperangle);
    return lv_finalpoint;
}

void libCNCC_gf_Accuraterotation (fixed lp_angleX, fixed lp_angleY, fixed lp_angleZ, actor lp_actor) {
    // Automatic Variable Declarations
    // Implementation
    ActorSend(lp_actor, libCNCC_gf_ZhunQueXuanZhuanFunc(lp_angleX, lp_angleY, lp_angleZ));
}

string libCNCC_gf_ZhunQueXuanZhuanFunc (fixed lp_angleX, fixed lp_angleY, fixed lp_angleZ) {
    // Variable Declarations
    fixed lv_forwardX;
    fixed lv_forwardY;
    fixed lv_forwardZ;
    fixed lv_upX;
    fixed lv_upY;
    fixed lv_upZ;
    fixed lv_oB;
    fixed lv_angleBOX;
    fixed lv_x;
    fixed lv_y;
    string lv_message;

    // Automatic Variable Declarations
    // Variable Initialization

    // Implementation
    lv_forwardX = (Cos(lp_angleY) * Cos(lp_angleZ));
    lv_forwardY = (Cos(lp_angleY) * Sin(lp_angleZ));
    lv_forwardZ = Sin(lp_angleY);
    lv_x = (Cos(lp_angleX) * Cos((lp_angleY + 90.0)));
    lv_y = Cos((lp_angleX + 90.0));
    lv_oB = SquareRoot(((lv_x * lv_x) + (lv_y * lv_y)));
    lv_angleBOX = (ATan2(lv_y, lv_x) + lp_angleZ);
    lv_upX = (lv_oB * Cos(lv_angleBOX));
    lv_upY = (lv_oB * Sin(lv_angleBOX));
    lv_upZ = (Cos(lp_angleX) * Sin((lp_angleY + 90.0)));
    lv_message = libCNCC_gf_Combinedaccuraterotation(lv_forwardX, lv_forwardY, lv_forwardZ, lv_upX, lv_upY, lv_upZ);
    return lv_message;
}

string libCNCC_gf_Combinedaccuraterotation (fixed lp_forward_X, fixed lp_forward_Y, fixed lp_forward_Z, fixed lp_up_X, fixed lp_up_Y, fixed lp_up_Z) {
    // Variable Declarations
    string lv_temp;

    // Automatic Variable Declarations
    // Variable Initialization
    lv_temp = "";

    // Implementation
    lv_temp = ("SetRotation {" + (libNtve_gf_Convert3DVectorToString(lp_forward_X, lp_forward_Y, lp_forward_Z) + " " + libNtve_gf_Convert3DVectorToString(lp_up_X, lp_up_Y, lp_up_Z)) + "}");
    return (lv_temp);
}

bool libCNCC_gf_Theanglebetweentheunitandthetargetpointisabout (unit lp_unit, point lp_point) {
    // Variable Declarations
    fixed lv_anglebetween;
    fixed lv_unitorientation;
    bool lv_oneispositiveandtheotherisnegative;
    unit lv_attackingunit;
    fixed lv_angle;
    point lv_centerpoint;
    point lv_movingtargetpoint;
    fixed lv_angledifference;
    fixed lv_preliminarydifference;
    bool lv_whetherthetargetpointistotheleftoftheunit;

    // Automatic Variable Declarations
    // Variable Initialization
    lv_oneispositiveandtheotherisnegative = true;

    // Implementation
    lv_anglebetween = AngleBetweenPoints(UnitGetPosition(lp_unit), lp_point);
    lv_unitorientation = UnitGetFacing(lp_unit);
    if (((lv_unitorientation >= 0.0) && (lv_anglebetween >= 0.0))) {
        lv_oneispositiveandtheotherisnegative = false;
        if (((lv_unitorientation >= lv_anglebetween))) {
            lv_whetherthetargetpointistotheleftoftheunit = false;
        }
        else {
            lv_whetherthetargetpointistotheleftoftheunit = true;
        }
    }

    if (((lv_unitorientation < 0.0) && (lv_anglebetween < 0.0))) {
        lv_oneispositiveandtheotherisnegative = false;
        if (((lv_unitorientation >= lv_anglebetween))) {
            lv_whetherthetargetpointistotheleftoftheunit = false;
        }
        else {
            lv_whetherthetargetpointistotheleftoftheunit = true;
        }
    }

    if ((lv_oneispositiveandtheotherisnegative == true)) {
        if ((lv_anglebetween < 0.0)) {
            lv_preliminarydifference = (lv_anglebetween-(lv_unitorientation - 360.0));
            if ((lv_preliminarydifference <= 180.0)) {
                lv_whetherthetargetpointistotheleftoftheunit = true;
            }
            else {
                lv_whetherthetargetpointistotheleftoftheunit = false;
            }
        }
        else {
            if ((lv_unitorientation < 0.0)) {
                lv_preliminarydifference = (lv_unitorientation-(lv_anglebetween - 360.0));
                if ((lv_preliminarydifference <= 180.0)) {
                    lv_whetherthetargetpointistotheleftoftheunit = false;
                }
                else {
                    lv_whetherthetargetpointistotheleftoftheunit = true;
                }
            }

        }
    }

    return lv_whetherthetargetpointistotheleftoftheunit;
}

trigger auto_libCNCC_gf_Actormessagerotation_Trigger = null;
unit auto_libCNCC_gf_Actormessagerotation_lp_attackingunit;
fixed auto_libCNCC_gf_Actormessagerotation_lp_headtiltangle;
fixed auto_libCNCC_gf_Actormessagerotation_lp_sidewaistangle;

void libCNCC_gf_Actormessagerotation (unit lp_attackingunit, fixed lp_headtiltangle, fixed lp_sidewaistangle) {
    auto_libCNCC_gf_Actormessagerotation_lp_attackingunit = lp_attackingunit;
    auto_libCNCC_gf_Actormessagerotation_lp_headtiltangle = lp_headtiltangle;
    auto_libCNCC_gf_Actormessagerotation_lp_sidewaistangle = lp_sidewaistangle;

    if (auto_libCNCC_gf_Actormessagerotation_Trigger == null) {
        auto_libCNCC_gf_Actormessagerotation_Trigger = TriggerCreate("auto_libCNCC_gf_Actormessagerotation_TriggerFunc");
    }

    TriggerExecute(auto_libCNCC_gf_Actormessagerotation_Trigger, false, false);
}

bool auto_libCNCC_gf_Actormessagerotation_TriggerFunc (bool testConds, bool runActions) {
    unit lp_attackingunit = auto_libCNCC_gf_Actormessagerotation_lp_attackingunit;
    fixed lp_headtiltangle = auto_libCNCC_gf_Actormessagerotation_lp_headtiltangle;
    fixed lp_sidewaistangle = auto_libCNCC_gf_Actormessagerotation_lp_sidewaistangle;

    // Automatic Variable Declarations
    // Implementation
    libNtve_gf_SendActorMessageToUnit(lp_attackingunit, libCNCC_gf_ZhunQueXuanZhuanFunc(lp_sidewaistangle, lp_headtiltangle, UnitGetFacing(lp_attackingunit)));
    return true;
}

fixed libCNCC_gf_Angledifferencebetweenunitandtargetpoint (unit lp_unit, point lp_point) {
    // Variable Declarations
    fixed lv_anglebetween;
    fixed lv_unitorientation;
    bool lv_oneispositiveandtheotherisnegative;
    unit lv_attackingunit;
    fixed lv_angle;
    point lv_centerpoint;
    point lv_movetargetpoint;
    fixed lv_angledifference;
    fixed lv_preliminarydifference;

    // Automatic Variable Declarations
    // Variable Initialization
    lv_oneispositiveandtheotherisnegative = true;

    // Implementation
    lv_anglebetween = AngleBetweenPoints(UnitGetPosition(lp_unit), lp_point);
    lv_unitorientation = UnitGetFacing(lp_unit);
    if (((lv_unitorientation >= 0.0) && (lv_anglebetween >= 0.0))) {
        lv_oneispositiveandtheotherisnegative = false;
        if (((lv_unitorientation >= lv_anglebetween))) {
            lv_angledifference = (lv_unitorientation - lv_anglebetween);
        }
        else {
            lv_angledifference = (lv_anglebetween - lv_unitorientation);
        }
    }

    if (((lv_unitorientation < 0.0) && (lv_anglebetween < 0.0))) {
        lv_oneispositiveandtheotherisnegative = false;
        lv_anglebetween = AbsF(lv_anglebetween);
        lv_unitorientation = AbsF(lv_unitorientation);
        if (((lv_unitorientation >= lv_anglebetween))) {
            lv_angledifference = (lv_unitorientation - lv_anglebetween);
        }
        else {
            lv_angledifference = (lv_anglebetween - lv_unitorientation);
        }
    }

    if ((lv_oneispositiveandtheotherisnegative == true)) {
        if ((lv_anglebetween < 0.0)) {
            lv_preliminarydifference = (lv_anglebetween-(lv_unitorientation - 360.0));
            if ((lv_preliminarydifference <= 180.0)) {
                lv_angledifference = lv_preliminarydifference;
            }
            else {
                lv_angledifference = (360.0 - lv_preliminarydifference);
            }
        }
        else {
            if ((lv_unitorientation < 0.0)) {
                lv_preliminarydifference = (lv_unitorientation-(lv_anglebetween - 360.0));
                if ((lv_preliminarydifference <= 180.0)) {
                    lv_angledifference = lv_preliminarydifference;
                }
                else {
                    lv_angledifference = (360.0 - lv_preliminarydifference);
                }
            }

        }
    }

    return lv_angledifference;
}

trigger auto_libCNCC_gf_Continuemovingtotargetpoint_Trigger = null;
unit auto_libCNCC_gf_Continuemovingtotargetpoint_lp_attackingunit;
point auto_libCNCC_gf_Continuemovingtotargetpoint_lp_point;
fixed auto_libCNCC_gf_Continuemovingtotargetpoint_lp_movingdistance;

void libCNCC_gf_Continuemovingtotargetpoint (unit lp_attackingunit, point lp_point, fixed lp_movingdistance) {
    auto_libCNCC_gf_Continuemovingtotargetpoint_lp_attackingunit = lp_attackingunit;
    auto_libCNCC_gf_Continuemovingtotargetpoint_lp_point = lp_point;
    auto_libCNCC_gf_Continuemovingtotargetpoint_lp_movingdistance = lp_movingdistance;

    if (auto_libCNCC_gf_Continuemovingtotargetpoint_Trigger == null) {
        auto_libCNCC_gf_Continuemovingtotargetpoint_Trigger = TriggerCreate("auto_libCNCC_gf_Continuemovingtotargetpoint_TriggerFunc");
    }

    TriggerExecute(auto_libCNCC_gf_Continuemovingtotargetpoint_Trigger, false, false);
}

bool auto_libCNCC_gf_Continuemovingtotargetpoint_TriggerFunc (bool testConds, bool runActions) {
    unit lp_attackingunit = auto_libCNCC_gf_Continuemovingtotargetpoint_lp_attackingunit;
    point lp_point = auto_libCNCC_gf_Continuemovingtotargetpoint_lp_point;
    fixed lp_movingdistance = auto_libCNCC_gf_Continuemovingtotargetpoint_lp_movingdistance;

    // Variable Declarations
    fixed lv_distance;
    point lv_predeterminedtargetpoint;

    // Automatic Variable Declarations
    const int autoE83A994A_n = 1;
    int autoE83A994A_i;

    // Variable Initialization

    // Implementation
    lv_distance = DistanceBetweenPoints(UnitGetPosition(lp_attackingunit), lp_point);
    for (autoE83A994A_i = 1; autoE83A994A_i <= autoE83A994A_n; autoE83A994A_i += 1) {
        lv_predeterminedtargetpoint = PointWithOffsetPolar(UnitGetPosition(lp_attackingunit), lp_movingdistance, AngleBetweenPoints(UnitGetPosition(lp_attackingunit), lp_point));
        if ((RegionContainsPoint(RegionPlayableMap(), lv_predeterminedtargetpoint) == true)) {
            libCNCC_gf_ContinuousOrientationAlgorithm(lp_attackingunit, lv_predeterminedtargetpoint);
            UnitCreateEffectPoint(lp_attackingunit, "SIInfestedBunkerUprootedRangedFarForcePush3", lv_predeterminedtargetpoint);
            Wait(0.0625, c_timeGame);
        }
        else {
            break;
        }
    }
    return true;
}

trigger auto_libCNCC_gf_ContinuousOrientationAlgorithm_Trigger = null;
unit auto_libCNCC_gf_ContinuousOrientationAlgorithm_lp_attackingunit;
point auto_libCNCC_gf_ContinuousOrientationAlgorithm_lp_point;

void libCNCC_gf_ContinuousOrientationAlgorithm (unit lp_attackingunit, point lp_point) {
    auto_libCNCC_gf_ContinuousOrientationAlgorithm_lp_attackingunit = lp_attackingunit;
    auto_libCNCC_gf_ContinuousOrientationAlgorithm_lp_point = lp_point;

    if (auto_libCNCC_gf_ContinuousOrientationAlgorithm_Trigger == null) {
        auto_libCNCC_gf_ContinuousOrientationAlgorithm_Trigger = TriggerCreate("auto_libCNCC_gf_ContinuousOrientationAlgorithm_TriggerFunc");
    }

    TriggerExecute(auto_libCNCC_gf_ContinuousOrientationAlgorithm_Trigger, false, false);
}

bool auto_libCNCC_gf_ContinuousOrientationAlgorithm_TriggerFunc (bool testConds, bool runActions) {
    unit lp_attackingunit = auto_libCNCC_gf_ContinuousOrientationAlgorithm_lp_attackingunit;
    point lp_point = auto_libCNCC_gf_ContinuousOrientationAlgorithm_lp_point;

    // Variable Declarations
    fixed lv_anglebetween;
    fixed lv_anglebetween2;
    fixed lv_unitorientation;
    fixed lv_unitOrientation2;
    bool lv_oneispositiveandtheotherisnegative;

    // Automatic Variable Declarations
    // Variable Initialization
    lv_oneispositiveandtheotherisnegative = true;

    // Implementation
    lv_anglebetween = AngleBetweenPoints(UnitGetPosition(lp_attackingunit), lp_point);
    lv_unitorientation = UnitGetFacing(lp_attackingunit);
    if (((lv_unitorientation >= 0.0) && (lv_anglebetween >= 0.0))) {
        if ((lv_unitorientation < (lv_anglebetween - 10.0))) {
            UnitSetFacing(lp_attackingunit, (lv_unitorientation + 10.0), 0.0625);
        }
        else {
            if ((lv_unitorientation > (lv_anglebetween + 10.0))) {
                UnitSetFacing(lp_attackingunit, (lv_unitorientation - 10.0), 0.0625);
            }
            else {
                UnitSetFacing(lp_attackingunit, lv_anglebetween, 0.0625);
            }
        }
        lv_oneispositiveandtheotherisnegative = false;
    }

    if (((lv_unitorientation < 0.0) && (lv_anglebetween < 0.0))) {
        if ((lv_unitorientation < (lv_anglebetween - 10.0))) {
            UnitSetFacing(lp_attackingunit, (lv_unitorientation + 10.0), 0.0625);
        }
        else {
            if ((lv_unitorientation > (lv_anglebetween + 10.0))) {
                UnitSetFacing(lp_attackingunit, (lv_unitorientation - 10.0), 0.0625);
            }
            else {
                UnitSetFacing(lp_attackingunit, lv_anglebetween, 0.0625);
            }
        }
        lv_oneispositiveandtheotherisnegative = false;
    }

    if ((lv_oneispositiveandtheotherisnegative == true)) {
        if ((lv_anglebetween < 0.0)) {
            if (((lv_unitorientation + (0.0 - lv_anglebetween)) <= 180.0)) {
                if (((lv_unitorientation + (0.0 - lv_anglebetween)) <= 10.0)) {
                    UnitSetFacing(lp_attackingunit, lv_anglebetween, 0.0625);
                }
                else {
                    UnitSetFacing(lp_attackingunit, (lv_unitorientation - 10.0), 0.0625);
                }
            }
            else {
                if (((lv_unitorientation + (0.0 - lv_anglebetween)) > 180.0)) {
                    if (((lv_unitorientation + (0.0 - lv_anglebetween)) >= 350.0)) {
                        UnitSetFacing(lp_attackingunit, lv_anglebetween, 0.0625);
                    }
                    else {
                        UnitSetFacing(lp_attackingunit, (lv_unitorientation + 10.0), 0.0625);
                    }
                }

            }
        }
        else {
            if ((lv_unitorientation < 0.0)) {
                if (((lv_anglebetween + (0.0 - lv_unitorientation)) <= 180.0)) {
                    if (((lv_anglebetween + (0.0 - lv_unitorientation)) <= 10.0)) {
                        UnitSetFacing(lp_attackingunit, lv_anglebetween, 0.0625);
                    }
                    else {
                        UnitSetFacing(lp_attackingunit, (lv_unitorientation + 10.0), 0.0625);
                    }
                }
                else {
                    if (((lv_anglebetween + (0.0 - lv_unitorientation)) > 180.0)) {
                        if (((lv_anglebetween + (0.0 - lv_unitorientation)) >= 350.0)) {
                            UnitSetFacing(lp_attackingunit, lv_anglebetween, 0.0625);
                        }
                        else {
                            UnitSetFacing(lp_attackingunit, (lv_unitorientation - 10.0), 0.0625);
                        }
                    }

                }
            }

        }
    }

    return true;
}

trigger auto_libCNCC_gf_OnecruisewhilestationaryAlliedfighteraircraft_Trigger = null;
unit auto_libCNCC_gf_OnecruisewhilestationaryAlliedfighteraircraft_lp_attackingunit;
point auto_libCNCC_gf_OnecruisewhilestationaryAlliedfighteraircraft_lp_centerpoint;

void libCNCC_gf_OnecruisewhilestationaryAlliedfighteraircraft (unit lp_attackingunit, point lp_centerpoint) {
    auto_libCNCC_gf_OnecruisewhilestationaryAlliedfighteraircraft_lp_attackingunit = lp_attackingunit;
    auto_libCNCC_gf_OnecruisewhilestationaryAlliedfighteraircraft_lp_centerpoint = lp_centerpoint;

    if (auto_libCNCC_gf_OnecruisewhilestationaryAlliedfighteraircraft_Trigger == null) {
        auto_libCNCC_gf_OnecruisewhilestationaryAlliedfighteraircraft_Trigger = TriggerCreate("auto_libCNCC_gf_OnecruisewhilestationaryAlliedfighteraircraft_TriggerFunc");
    }

    TriggerExecute(auto_libCNCC_gf_OnecruisewhilestationaryAlliedfighteraircraft_Trigger, false, false);
}

bool auto_libCNCC_gf_OnecruisewhilestationaryAlliedfighteraircraft_TriggerFunc (bool testConds, bool runActions) {
    unit lp_attackingunit = auto_libCNCC_gf_OnecruisewhilestationaryAlliedfighteraircraft_lp_attackingunit;
    point lp_centerpoint = auto_libCNCC_gf_OnecruisewhilestationaryAlliedfighteraircraft_lp_centerpoint;

    // Variable Declarations
    point lv_movetargetpoint;

    // Automatic Variable Declarations
    // Variable Initialization

    // Implementation
    UnitBehaviorAdd(lp_attackingunit, "VanguardIsCircling", lp_attackingunit, 1);
    lv_movetargetpoint = libCNCC_gf_HoveringAcquisitionPointPeacekeeperBomber(lp_attackingunit, lp_centerpoint);
    libCNCC_gf_Continuemovingtotargetpoint(lp_attackingunit, lv_movetargetpoint, 0.2);
    return true;
}

trigger auto_libCNCC_gf_Cruiseoncewhilestopped_Trigger = null;
unit auto_libCNCC_gf_Cruiseoncewhilestopped_lp_attackingunit;
point auto_libCNCC_gf_Cruiseoncewhilestopped_lp_centerpoint;

void libCNCC_gf_Cruiseoncewhilestopped (unit lp_attackingunit, point lp_centerpoint) {
    auto_libCNCC_gf_Cruiseoncewhilestopped_lp_attackingunit = lp_attackingunit;
    auto_libCNCC_gf_Cruiseoncewhilestopped_lp_centerpoint = lp_centerpoint;

    if (auto_libCNCC_gf_Cruiseoncewhilestopped_Trigger == null) {
        auto_libCNCC_gf_Cruiseoncewhilestopped_Trigger = TriggerCreate("auto_libCNCC_gf_Cruiseoncewhilestopped_TriggerFunc");
    }

    TriggerExecute(auto_libCNCC_gf_Cruiseoncewhilestopped_Trigger, false, false);
}

bool auto_libCNCC_gf_Cruiseoncewhilestopped_TriggerFunc (bool testConds, bool runActions) {
    unit lp_attackingunit = auto_libCNCC_gf_Cruiseoncewhilestopped_lp_attackingunit;
    point lp_centerpoint = auto_libCNCC_gf_Cruiseoncewhilestopped_lp_centerpoint;

    // Variable Declarations
    point lv_movetargetpoint;

    // Automatic Variable Declarations
    // Variable Initialization

    // Implementation
    UnitBehaviorAdd(lp_attackingunit, "VanguardIsCircling", lp_attackingunit, 1);
    lv_movetargetpoint = libCNCC_gf_SurroundAttackAcquisitionPoint(lp_attackingunit, lp_centerpoint);
    libCNCC_gf_Continuemovingtotargetpoint(lp_attackingunit, lv_movetargetpoint, 0.2);
    return true;
}

trigger auto_libCNCC_gf_Cruiseoncewhendestroyingatarget_Trigger = null;
unit auto_libCNCC_gf_Cruiseoncewhendestroyingatarget_lp_attackingunit;
point auto_libCNCC_gf_Cruiseoncewhendestroyingatarget_lp_centerpoint;

void libCNCC_gf_Cruiseoncewhendestroyingatarget (unit lp_attackingunit, point lp_centerpoint) {
    auto_libCNCC_gf_Cruiseoncewhendestroyingatarget_lp_attackingunit = lp_attackingunit;
    auto_libCNCC_gf_Cruiseoncewhendestroyingatarget_lp_centerpoint = lp_centerpoint;

    if (auto_libCNCC_gf_Cruiseoncewhendestroyingatarget_Trigger == null) {
        auto_libCNCC_gf_Cruiseoncewhendestroyingatarget_Trigger = TriggerCreate("auto_libCNCC_gf_Cruiseoncewhendestroyingatarget_TriggerFunc");
    }

    TriggerExecute(auto_libCNCC_gf_Cruiseoncewhendestroyingatarget_Trigger, false, false);
}

bool auto_libCNCC_gf_Cruiseoncewhendestroyingatarget_TriggerFunc (bool testConds, bool runActions) {
    unit lp_attackingunit = auto_libCNCC_gf_Cruiseoncewhendestroyingatarget_lp_attackingunit;
    point lp_centerpoint = auto_libCNCC_gf_Cruiseoncewhendestroyingatarget_lp_centerpoint;

    // Variable Declarations
    point lv_movetargetpoint;

    // Automatic Variable Declarations
    // Variable Initialization

    // Implementation
    UnitBehaviorAdd(lp_attackingunit, "VanguardIsCircling", lp_attackingunit, 1);
    lv_movetargetpoint = libCNCC_gf_SurroundAttackAcquisitionPoint(lp_attackingunit, lp_centerpoint);
    libCNCC_gf_Continuemovingtotargetpoint(lp_attackingunit, lv_movetargetpoint, 0.2);
    return true;
}

point libCNCC_gf_SurroundAttackAcquisitionPoint (unit lp_attackingunit, point lp_locationoftheattackedunit) {
    // Variable Declarations
    point[37] lv_circlePoint;
    int lv_a;
    int lv_b;
    fixed lv_distance;
    point lv_closestpoint;
    fixed lv_anglefromcentertonearestpoint;
    fixed lv_theproperangle;
    point lv_finalpoint;

    // Automatic Variable Declarations
    // Variable Initialization
    lv_distance = 200.0;

    // Implementation
    lv_anglefromcentertonearestpoint = AngleBetweenPoints(lp_locationoftheattackedunit, UnitGetPosition(lp_attackingunit));
    if (((TechTreeUnitCount(1, "Nexus", c_techCountCompleteOnly) == 1) && (lv_anglefromcentertonearestpoint < -150.0) && (lv_anglefromcentertonearestpoint > -180.0))) {
        lv_theproperangle = (180.0 - (lv_anglefromcentertonearestpoint - -180.0));
    }
    else {
        lv_theproperangle = (lv_anglefromcentertonearestpoint - 30.0);
    }
    lv_finalpoint = PointWithOffsetPolar(lp_locationoftheattackedunit, 10.0, lv_theproperangle);
    return lv_finalpoint;
}

point libCNCC_gf_SurroundAttackAcquisitionPointLargeBomber (unit lp_attackingunit, point lp_locationoftheattackedunit) {
    // Variable Declarations
    point[37] lv_circlepoint;
    int lv_a;
    int lv_b;
    fixed lv_distance;
    point lv_closestpoint;
    fixed lv_anglefromcentertonearestpoint;
    fixed lv_theproperangle;
    point lv_finalpoint;

    // Automatic Variable Declarations
    // Variable Initialization
    lv_distance = 200.0;

    // Implementation
    lv_anglefromcentertonearestpoint = AngleBetweenPoints(lp_locationoftheattackedunit, UnitGetPosition(lp_attackingunit));
    if (((TechTreeUnitCount(1, "Nexus", c_techCountCompleteOnly) == 1) && (lv_anglefromcentertonearestpoint < -150.0) && (lv_anglefromcentertonearestpoint > -180.0))) {
        lv_theproperangle = (180.0 - (lv_anglefromcentertonearestpoint - -180.0));
    }
    else {
        lv_theproperangle = (lv_anglefromcentertonearestpoint - 30.0);
    }
    lv_finalpoint = PointWithOffsetPolar(lp_locationoftheattackedunit, 10.0, lv_theproperangle);
    return lv_finalpoint;
}

point libCNCC_gf_OrbitalAttackAcquisitionPointPeacekeeperBomber (unit lp_attackingunit, point lp_locationoftheattackedunit) {
    // Variable Declarations
    point[37] lv_circlepoint;
    int lv_a;
    int lv_b;
    fixed lv_distance;
    point lv_closestpoint;
    fixed lv_anglefromcentertonearestpoint;
    fixed lv_theproperangle;
    point lv_finalpoint;

    // Automatic Variable Declarations
    // Variable Initialization
    lv_distance = 200.0;

    // Implementation
    lv_anglefromcentertonearestpoint = AngleBetweenPoints(lp_locationoftheattackedunit, UnitGetPosition(lp_attackingunit));
    if (((TechTreeUnitCount(1, "Nexus", c_techCountCompleteOnly) == 1) && (lv_anglefromcentertonearestpoint < -150.0) && (lv_anglefromcentertonearestpoint > -180.0))) {
        lv_theproperangle = (180.0 - (lv_anglefromcentertonearestpoint - -180.0));
    }
    else {
        lv_theproperangle = (lv_anglefromcentertonearestpoint - 30.0);
    }
    lv_finalpoint = PointWithOffsetPolar(UnitGetPosition(lp_attackingunit), 1.0, lv_theproperangle);
    return lv_finalpoint;
}

point libCNCC_gf_HoveringAcquisitionPointPeacekeeperBomber (unit lp_attackingunit, point lp_locationoftheattackedunit) {
    // Variable Declarations
    point[37] lv_circlePoint;
    int lv_a;
    int lv_b;
    fixed lv_distance;
    point lv_closestpoint;
    fixed lv_anglefromcentertonearestpoint;
    fixed lv_theproperangle;
    point lv_finalpoint;

    // Automatic Variable Declarations
    // Variable Initialization
    lv_distance = 200.0;

    // Implementation
    lv_anglefromcentertonearestpoint = AngleBetweenPoints(lp_locationoftheattackedunit, UnitGetPosition(lp_attackingunit));
    if (((TechTreeUnitCount(1, "Nexus", c_techCountCompleteOnly) == 1) && (lv_anglefromcentertonearestpoint < -150.0) && (lv_anglefromcentertonearestpoint > -180.0))) {
        lv_theproperangle = (180.0 - (lv_anglefromcentertonearestpoint - -180.0));
    }
    else {
        lv_theproperangle = (lv_anglefromcentertonearestpoint - 30.0);
    }
    lv_finalpoint = PointWithOffsetPolar(lp_locationoftheattackedunit, 3.0, lv_theproperangle);
    return lv_finalpoint;
}

point libCNCC_gf_Circleacquisitionpointotherlargebombers (unit lp_attackingunit, point lp_locationoftheattackedunit) {
    // Variable Declarations
    point[37] lv_circlepoint;
    int lv_a;
    int lv_b;
    fixed lv_distance;
    point lv_closestpoint;
    fixed lv_anglefromcentertonearestpoint;
    fixed lv_theproperangle;
    point lv_finalpoint;

    // Automatic Variable Declarations
    // Variable Initialization
    lv_distance = 200.0;

    // Implementation
    lv_anglefromcentertonearestpoint = AngleBetweenPoints(lp_locationoftheattackedunit, UnitGetPosition(lp_attackingunit));
    if (((TechTreeUnitCount(1, "Nexus", c_techCountCompleteOnly) == 1) && (lv_anglefromcentertonearestpoint < -150.0) && (lv_anglefromcentertonearestpoint > -180.0))) {
        lv_theproperangle = (180.0 - (lv_anglefromcentertonearestpoint - -180.0));
    }
    else {
        lv_theproperangle = (lv_anglefromcentertonearestpoint - 30.0);
    }
    lv_finalpoint = PointWithOffsetPolar(lp_locationoftheattackedunit, 10.0, lv_theproperangle);
    return lv_finalpoint;
}

// Triggers
//--------------------------------------------------------------------------------------------------
// Trigger: Watch Unit Creation
//--------------------------------------------------------------------------------------------------
bool libCNCC_gt_WatchUnitCreation_Func (bool testConds, bool runActions) {
    // Automatic Variable Declarations
    // Actions
    if (!runActions) {
        return true;
    }

    libCNCC_gf_RegisterUnit(EventUnitCreatedUnit(), UnitGetOwner(EventUnitCreatedUnit()));
    return true;
}

//--------------------------------------------------------------------------------------------------
void libCNCC_gt_WatchUnitCreation_Init () {
    libCNCC_gt_WatchUnitCreation = TriggerCreate("libCNCC_gt_WatchUnitCreation_Func");
    TriggerAddEventUnitCreated(libCNCC_gt_WatchUnitCreation, null, null, null);
}

//--------------------------------------------------------------------------------------------------
// Trigger: Watch Unit Owner
//--------------------------------------------------------------------------------------------------
bool libCNCC_gt_WatchUnitOwner_Func (bool testConds, bool runActions) {
    // Automatic Variable Declarations
    // Actions
    if (!runActions) {
        return true;
    }

    libCNCC_gf_UnRegisterUnit(EventUnit(), EventUnitOwnerOld());
    libCNCC_gf_RegisterUnit(EventUnit(), EventUnitOwnerNew());
    return true;
}

//--------------------------------------------------------------------------------------------------
void libCNCC_gt_WatchUnitOwner_Init () {
    libCNCC_gt_WatchUnitOwner = TriggerCreate("libCNCC_gt_WatchUnitOwner_Func");
    TriggerAddEventUnitChangeOwner(libCNCC_gt_WatchUnitOwner, null);
}

//--------------------------------------------------------------------------------------------------
// Trigger: Watch Unit Death
//--------------------------------------------------------------------------------------------------
bool libCNCC_gt_WatchUnitDeath_Func (bool testConds, bool runActions) {
    // Automatic Variable Declarations
    // Actions
    if (!runActions) {
        return true;
    }

    libCNCC_gf_UnRegisterUnit(EventUnit(), UnitGetOwner(EventUnit()));
    return true;
}

//--------------------------------------------------------------------------------------------------
void libCNCC_gt_WatchUnitDeath_Init () {
    libCNCC_gt_WatchUnitDeath = TriggerCreate("libCNCC_gt_WatchUnitDeath_Func");
    TriggerAddEventUnitDied(libCNCC_gt_WatchUnitDeath, null);
    TriggerAddEventUnitRemoved(libCNCC_gt_WatchUnitDeath, null);
}

//--------------------------------------------------------------------------------------------------
// Trigger: Watch Unit Behaviors
//--------------------------------------------------------------------------------------------------
bool libCNCC_gt_WatchUnitBehaviors_Func (bool testConds, bool runActions) {
    // Variable Declarations
    int lv_techType;

    // Automatic Variable Declarations
    string autoBF56171B_val;

    // Variable Initialization

    // Actions
    if (!runActions) {
        return true;
    }

    autoBF56171B_val = EventUnitBehavior();
    if (autoBF56171B_val == "CNCTabConstruction") {
        lv_techType = 1;
    }
    else if (autoBF56171B_val == "CNCTabEconomy") {
        lv_techType = 2;
    }
    else if (autoBF56171B_val == "CNCTabInfantry") {
        lv_techType = 3;
    }
    else if (autoBF56171B_val == "CNCTabVehicles") {
        lv_techType = 4;
    }
    else if (autoBF56171B_val == "CNCTabAirforce") {
        lv_techType = 5;
    }
    else {
    }
    if ((EventUnitBehaviorChange() == c_unitBehaviorChangeDecrease)) {
        libCNCC_gf_DeleteProductionUnit(EventUnit(), UnitGetOwner(EventUnit()), lv_techType);
    }
    else if ((EventUnitBehaviorChange() == c_unitBehaviorChangeIncrease)) {
        libCNCC_gf_AddproductionUnit(EventUnit(), UnitGetOwner(EventUnit()), lv_techType);
    }
    return true;
}

//--------------------------------------------------------------------------------------------------
void libCNCC_gt_WatchUnitBehaviors_Init () {
    libCNCC_gt_WatchUnitBehaviors = TriggerCreate("libCNCC_gt_WatchUnitBehaviors_Func");
    TriggerAddEventUnitBehaviorChange(libCNCC_gt_WatchUnitBehaviors, null, "CNCTabConstruction", c_unitBehaviorChangeAny);
    TriggerAddEventUnitBehaviorChange(libCNCC_gt_WatchUnitBehaviors, null, "CNCTabAirforce", c_unitBehaviorChangeAny);
    TriggerAddEventUnitBehaviorChange(libCNCC_gt_WatchUnitBehaviors, null, "CNCTabEconomy", c_unitBehaviorChangeAny);
    TriggerAddEventUnitBehaviorChange(libCNCC_gt_WatchUnitBehaviors, null, "CNCTabInfantry", c_unitBehaviorChangeAny);
    TriggerAddEventUnitBehaviorChange(libCNCC_gt_WatchUnitBehaviors, null, "CNCTabVehicles", c_unitBehaviorChangeAny);
}

//--------------------------------------------------------------------------------------------------
// Trigger: Recalculate Beacons
//--------------------------------------------------------------------------------------------------
bool libCNCC_gt_RecalculateBeacons_Func (bool testConds, bool runActions) {
    // Variable Declarations
    int lv_untitledVariable001;
    unitgroup lv_units;
    int lv_techType;
    string lv_unitType;
    int lv_player;
    int lv_living;
    string lv_instance;

    // Automatic Variable Declarations
    playergroup auto14BDCE08_g;
    const int auto78F39873_ae = libCNCC_gv_beaconGroups;
    const int auto78F39873_ai = 1;
    string autoDFC98E70_userType;
    int autoDFC98E70_i;
    const int auto1481BA21_ae = libCNCC_gv_beaconGroups;
    const int auto1481BA21_ai = 1;

    // Variable Initialization
    lv_units = UnitGroupEmpty();

    // Actions
    if (!runActions) {
        return true;
    }

    auto14BDCE08_g = PlayerGroupActive();
    lv_player = -1;
    while (true) {
        lv_player = PlayerGroupNextPlayer(auto14BDCE08_g, lv_player);
        if (lv_player < 0) { break; }
        lv_techType = 1;
        for ( ; ( (auto78F39873_ai >= 0 && lv_techType <= auto78F39873_ae) || (auto78F39873_ai < 0 && lv_techType >= auto78F39873_ae) ) ; lv_techType += auto78F39873_ai ) {
            libCNCC_gv_productionUnits[lv_player][lv_techType] = UnitGroupEmpty();
        }
        autoDFC98E70_userType = "cncTech";
        autoDFC98E70_i = 1;
        for ( ; autoDFC98E70_i <= UserDataInstanceCount(autoDFC98E70_userType) ; autoDFC98E70_i += 1 ) {
            lv_instance = UserDataInstance(autoDFC98E70_userType, autoDFC98E70_i);
            lv_unitType = UserDataGetUnit("cncTech", lv_instance, "Unit", 1);
            lv_units = UnitGroup(lv_unitType, lv_player, RegionEntireMap(), UnitFilter(0, 0, (1 << c_targetFilterMissile), (1 << (c_targetFilterUnderConstruction - 32)) | (1 << (c_targetFilterDead - 32)) | (1 << (c_targetFilterHidden - 32))), 0);
            lv_techType = UserDataGetInt("cncTech", lv_instance, "Tech", 1);
            UnitGroupAddUnitGroup(libCNCC_gv_productionUnits[lv_player][lv_techType], lv_units);
        }
        lv_techType = 1;
        for ( ; ( (auto1481BA21_ai >= 0 && lv_techType <= auto1481BA21_ae) || (auto1481BA21_ai < 0 && lv_techType >= auto1481BA21_ae) ) ; lv_techType += auto1481BA21_ai ) {
            lv_living = UnitGroupCount(libCNCC_gv_productionUnits[lv_player][lv_techType], c_unitCountAlive);
            libNtve_gf_SetDialogItemText(libCNCC_gv_labels[lv_techType], IntToText(lv_living), PlayerGroupSingle(lv_player));
            if ((lv_living == 0)) {
                DialogControlSetEnabled(libCNCC_gv_buttons[lv_techType], PlayerGroupSingle(lv_player), false);
            }
            else {
                DialogControlSetEnabled(libCNCC_gv_buttons[lv_techType], PlayerGroupSingle(lv_player), true);
            }
        }
    }
    return true;
}

//--------------------------------------------------------------------------------------------------
void libCNCC_gt_RecalculateBeacons_Init () {
    libCNCC_gt_RecalculateBeacons = TriggerCreate("libCNCC_gt_RecalculateBeacons_Func");
}

//--------------------------------------------------------------------------------------------------
// Trigger: Init Beacons Button
//--------------------------------------------------------------------------------------------------
bool libCNCC_gt_InitBeaconsButton_Func (bool testConds, bool runActions) {
    // Variable Declarations
    int lv_untitledVariable001;
    unitgroup lv_units;
    int lv_techType;
    string lv_unitType;
    int lv_player;
    int lv_living;
    string lv_instance;

    // Automatic Variable Declarations
    const int auto93AEDC4D_ae = libCNCC_gv_beaconGroups;
    int auto93AEDC4D_var;
    string auto965F558F_userType;
    int auto965F558F_i;

    // Variable Initialization
    lv_units = UnitGroupEmpty();

    // Actions
    if (!runActions) {
        return true;
    }

    auto93AEDC4D_var = 1;
    for ( ; auto93AEDC4D_var <= auto93AEDC4D_ae; auto93AEDC4D_var += 1 ) {
        DialogControlHookupStandard(c_triggerControlTypeButton, ("UIContainer/ConsoleUIContainer/ArmyButton" + IntToString((auto93AEDC4D_var + 1))));
        libCNCC_gv_buttons[auto93AEDC4D_var] = DialogControlLastCreated();
        DialogControlHookupStandard(c_triggerControlTypeLabel, ("UIContainer/ConsoleUIContainer/ArmyButton" + IntToString((auto93AEDC4D_var + 1)) + "/CountLabel"));
        libCNCC_gv_labels[auto93AEDC4D_var] = DialogControlLastCreated();
        libCNCC_gv_watchTypes[lv_techType] = " ";
    }
    auto965F558F_userType = "cncTech";
    auto965F558F_i = 1;
    for ( ; auto965F558F_i <= UserDataInstanceCount(auto965F558F_userType) ; auto965F558F_i += 1 ) {
        lv_instance = UserDataInstance(auto965F558F_userType, auto965F558F_i);
        lv_unitType = UserDataGetUnit("cncTech", lv_instance, "Unit", 1);
        lv_techType = UserDataGetInt("cncTech", lv_instance, "Tech", 1);
        libCNCC_gv_watchTypes[lv_techType] = (libCNCC_gv_watchTypes[lv_techType] + (lv_unitType) + " ");
    }
    TriggerExecute(libCNCC_gt_RecalculateBeacons, true, false);
    TriggerEnable(libCNCC_gt_WatchUnitCreation, true);
    TriggerEnable(libCNCC_gt_BeaconsButtonUsed, true);
    return true;
}

//--------------------------------------------------------------------------------------------------
void libCNCC_gt_InitBeaconsButton_Init () {
    libCNCC_gt_InitBeaconsButton = TriggerCreate("libCNCC_gt_InitBeaconsButton_Func");
}

//--------------------------------------------------------------------------------------------------
// Trigger: Beacons Button Used
//--------------------------------------------------------------------------------------------------
bool libCNCC_gt_BeaconsButtonUsed_Func (bool testConds, bool runActions) {
    // Automatic Variable Declarations
    const int auto241A39EC_ae = libCNCC_gv_beaconGroups;
    int auto241A39EC_var;

    // Actions
    if (!runActions) {
        return true;
    }

    auto241A39EC_var = 1;
    for ( ; auto241A39EC_var <= auto241A39EC_ae; auto241A39EC_var += 1 ) {
        if ((EventDialogControl() == libCNCC_gv_buttons[auto241A39EC_var])) {
            UnitGroupSelect(UnitGroupSelected(EventPlayer()), EventPlayer(), false);
            UnitGroupSelect(libCNCC_gv_productionUnits[EventPlayer()][auto241A39EC_var], EventPlayer(), true);
            break;
        }

    }
    return true;
}

//--------------------------------------------------------------------------------------------------
void libCNCC_gt_BeaconsButtonUsed_Init () {
    libCNCC_gt_BeaconsButtonUsed = TriggerCreate("libCNCC_gt_BeaconsButtonUsed_Func");
    TriggerAddEventDialogControl(libCNCC_gt_BeaconsButtonUsed, c_playerAny, c_invalidDialogControlId, c_triggerControlEventTypeHotkeyPressed);
    TriggerAddEventDialogControl(libCNCC_gt_BeaconsButtonUsed, c_playerAny, c_invalidDialogControlId, c_triggerControlEventTypeClick);
}

//--------------------------------------------------------------------------------------------------
// Trigger: Production UI
//--------------------------------------------------------------------------------------------------
bool libCNCC_gt_ProductionUI_Func (bool testConds, bool runActions) {
    // Variable Declarations
    int lv_player;

    // Automatic Variable Declarations
    // Variable Initialization
    lv_player = EventPlayer();

    // Actions
    if (!runActions) {
        return true;
    }

    if ((GameIsMissionTimePaused() == true)) {
        if ((PlayerGroupHasPlayer(libCNCC_gv_aF_SlimUI_PlayerGroup, lv_player) == false)) {
            PlayerGroupAdd(libCNCC_gv_aF_SlimUI_PlayerGroup, lv_player);
            UIDisplayMessage(PlayerGroupSingle(lv_player), c_messageAreaSubtitle, StringExternal("Param/Value/lib_CNCC_8F8A34D8"));
        }
        else {
            PlayerGroupRemove(libCNCC_gv_aF_SlimUI_PlayerGroup, lv_player);
            UIDisplayMessage(PlayerGroupSingle(lv_player), c_messageAreaSubtitle, StringExternal("Param/Value/lib_CNCC_0C0F049F"));
        }
    }
    else {
        DialogControlHookupStandard(c_triggerControlTypePanel, "UIContainer/ConsoleUIContainer");
        if ((PlayerGroupHasPlayer(libCNCC_gv_aF_SlimUI_PlayerGroup, lv_player) == false)) {
            PlayerGroupAdd(libCNCC_gv_aF_SlimUI_PlayerGroup, lv_player);
            UISetFrameVisible(PlayerGroupSingle(lv_player), c_syncFrameTypeConsolePanel, false);
            DialogControlSendAnimationEvent(DialogControlLastCreated(), PlayerGroupSingle(lv_player), "SlimUI_On");
        }
        else {
            PlayerGroupRemove(libCNCC_gv_aF_SlimUI_PlayerGroup, lv_player);
            UISetFrameVisible(PlayerGroupSingle(lv_player), c_syncFrameTypeConsolePanel, true);
            DialogControlSendAnimationEvent(DialogControlLastCreated(), PlayerGroupSingle(lv_player), "SlimUI_Off");
        }
    }
    return true;
}

//--------------------------------------------------------------------------------------------------
void libCNCC_gt_ProductionUI_Init () {
    libCNCC_gt_ProductionUI = TriggerCreate("libCNCC_gt_ProductionUI_Func");
    TriggerAddEventChatMessage(libCNCC_gt_ProductionUI, c_playerAny, "-slim", false);
}

//--------------------------------------------------------------------------------------------------
// Trigger: Unit upgrade special effects
//--------------------------------------------------------------------------------------------------
bool libCNCC_gt_Unitupgradespecialeffects_Func (bool testConds, bool runActions) {
    // Automatic Variable Declarations
    // Actions
    if (!runActions) {
        return true;
    }

    libNtve_gf_AttachActorToUnit(EventUnit(), "K5KerriganLevelUp2", "Ref_Origin");
    return true;
}

//--------------------------------------------------------------------------------------------------
void libCNCC_gt_Unitupgradespecialeffects_Init () {
    libCNCC_gt_Unitupgradespecialeffects = TriggerCreate("libCNCC_gt_Unitupgradespecialeffects_Func");
    TriggerAddEventUnitGainLevel(libCNCC_gt_Unitupgradespecialeffects, null);
}

//--------------------------------------------------------------------------------------------------
// Trigger: Units gain experience by rising stars.
//--------------------------------------------------------------------------------------------------
bool libCNCC_gt_Unitsgainexperiencebyrisingstars_Func (bool testConds, bool runActions) {
    // Automatic Variable Declarations
    int auto470B3FD4_val;

    // Conditions
    if (testConds) {
        if (!((UnitGetOwner(EventUnit()) != 1))) {
            return false;
        }
    }

    // Actions
    if (!runActions) {
        return true;
    }

    auto470B3FD4_val = TechTreeUpgradeCount(1, "AlliedTechlvP132", c_techCountCompleteOnly);
    if (auto470B3FD4_val == 1) {
        UnitXPAddXP(libNtve_gf_KillingUnit(), null, ((UnitTypeGetCost(UnitGetType(EventUnit()), c_unitCostSumMineralsVespene) / 16.0) + ((UnitGetPropertyFixed(EventUnit(), c_unitPropLifeMax, c_unitPropNormal) + UnitGetPropertyFixed(EventUnit(), c_unitPropShieldsMax, c_unitPropNormal)) / 32.0)));
    }
    else {
        UnitXPAddXP(libNtve_gf_KillingUnit(), null, ((UnitTypeGetCost(UnitGetType(EventUnit()), c_unitCostSumMineralsVespene) / 20.0) + ((UnitGetPropertyFixed(EventUnit(), c_unitPropLifeMax, c_unitPropNormal) + UnitGetPropertyFixed(EventUnit(), c_unitPropShieldsMax, c_unitPropNormal)) / 40.0)));
    }
    return true;
}

//--------------------------------------------------------------------------------------------------
void libCNCC_gt_Unitsgainexperiencebyrisingstars_Init () {
    libCNCC_gt_Unitsgainexperiencebyrisingstars = TriggerCreate("libCNCC_gt_Unitsgainexperiencebyrisingstars_Func");
    TriggerAddEventUnitDied(libCNCC_gt_Unitsgainexperiencebyrisingstars, null);
}

//--------------------------------------------------------------------------------------------------
// Trigger: Maintenance bee height adjustment
//--------------------------------------------------------------------------------------------------
bool libCNCC_gt_Maintenancebeeheightadjustment_Func (bool testConds, bool runActions) {
    // Automatic Variable Declarations
    // Conditions
    if (testConds) {
        if (!((UnitGetType(EventPlayerEffectUsedUnit(c_effectUnitCaster)) == "AlliedRepairBee"))) {
            return false;
        }
    }

    // Actions
    if (!runActions) {
        return true;
    }

    UnitSetHeight(EventPlayerEffectUsedUnit(c_effectUnitCaster), (UnitGetHeight(EventPlayerEffectUsedUnitImpact()) + 0.6), 1.0);
    return true;
}

//--------------------------------------------------------------------------------------------------
void libCNCC_gt_Maintenancebeeheightadjustment_Init () {
    libCNCC_gt_Maintenancebeeheightadjustment = TriggerCreate("libCNCC_gt_Maintenancebeeheightadjustment_Func");
    TriggerAddEventPlayerEffectUsed(libCNCC_gt_Maintenancebeeheightadjustment, c_playerAny, "Repair3");
}

//--------------------------------------------------------------------------------------------------
// Trigger: Maintenance bee height restored
//--------------------------------------------------------------------------------------------------
bool libCNCC_gt_Maintenancebeeheightrestored_Func (bool testConds, bool runActions) {
    // Automatic Variable Declarations
    // Actions
    if (!runActions) {
        return true;
    }

    UnitSetHeight(EventPlayerEffectUsedUnitImpact(), 3.75, 1.5);
    return true;
}

//--------------------------------------------------------------------------------------------------
void libCNCC_gt_Maintenancebeeheightrestored_Init () {
    libCNCC_gt_Maintenancebeeheightrestored = TriggerCreate("libCNCC_gt_Maintenancebeeheightrestored_Func");
    TriggerAddEventPlayerEffectUsed(libCNCC_gt_Maintenancebeeheightrestored, c_playerAny, "AurepairDroneHighstart2");
}

//--------------------------------------------------------------------------------------------------
// Trigger: AIRSUPPORT CREATED
//--------------------------------------------------------------------------------------------------
bool libCNCC_gt_AIRSUPPORTCREATED_Func (bool testConds, bool runActions) {
    // Variable Declarations
    unit lv_airport;
    unit lv_slotUnit;
    string lv_slotUnitType;
    string lv_uD;
    string lv_uDTemp;
    int lv_slot;

    // Automatic Variable Declarations
    string auto7FD1CE79_userType;
    int auto7FD1CE79_i;
    int auto9060DEB7_ae;
    const int auto9060DEB7_ai = 1;

    // Variable Initialization
    lv_airport = EventUnitCreatedUnit();

    // Conditions
    if (testConds) {
        if (!((UnitHasBehavior2(lv_airport, "AirSupport") == true))) {
            return false;
        }
    }

    // Actions
    if (!runActions) {
        return true;
    }

    auto7FD1CE79_userType = "Airports";
    auto7FD1CE79_i = 1;
    for ( ; auto7FD1CE79_i <= UserDataInstanceCount(auto7FD1CE79_userType) ; auto7FD1CE79_i += 1 ) {
        lv_uDTemp = UserDataInstance(auto7FD1CE79_userType, auto7FD1CE79_i);
        if ((UnitGetType(lv_airport) == UserDataGetUnit("Airports", lv_uDTemp, "Airport", 1))) {
            lv_uD = lv_uDTemp;
            break;
        }

    }
    if ((lv_uD == null)) {
        return true;
    }

    auto9060DEB7_ae = UserDataGetInt("Airports", lv_uD, "Slots", 1);
    lv_slot = 1;
    for ( ; ( (auto9060DEB7_ai >= 0 && lv_slot <= auto9060DEB7_ae) || (auto9060DEB7_ai < 0 && lv_slot >= auto9060DEB7_ae) ) ; lv_slot += auto9060DEB7_ai ) {
        lv_slotUnitType = UserDataGetUnit("Airports", lv_uD, "SlotUnit", lv_slot);
        if ((lv_slotUnitType == null)) {
            lv_slotUnitType = "DockDummy";
        }

        libNtve_gf_CreateUnitsWithDefaultFacing(1, lv_slotUnitType, c_unitCreateIgnorePlacement, UnitGetOwner(lv_airport), UnitGetPosition(lv_airport));
        lv_slotUnit = UnitLastCreated();
        UnitSetState(lv_slotUnit, c_unitStateInvulnerable, true);
        UnitSetState(lv_slotUnit, c_unitStateTargetable, false);
        UnitSetState(lv_slotUnit, c_unitStateSelectable, false);
        libCNCC_gf_AttachUnitModelToUnit(lv_slotUnit, lv_airport, ("Ref_Hardpoint 0" + IntToString(lv_slot)), 0.0, 0.0, 0.0, "SOp270");
        UnitSetCustomValue(lv_slotUnit, 1, UserDataGetFixed("Airports", lv_uD, "SlotsOffsetX", lv_slot));
        UnitSetCustomValue(lv_slotUnit, 2, UserDataGetFixed("Airports", lv_uD, "SlotsOffsetY", lv_slot));
        UnitSetCustomValue(lv_slotUnit, 3, UserDataGetFixed("Airports", lv_uD, "SlotsHeight", lv_slot));
        UnitSetCustomValue(lv_slotUnit, 4, UserDataGetFixed("Airports", lv_uD, "SlotsFacing", lv_slot));
        UnitSetCustomValue(lv_slotUnit, 5, lv_slot);
        UnitBehaviorAdd(lv_slotUnit, "SuicideWithCaster", lv_airport, 1);
    }
    return true;
}

//--------------------------------------------------------------------------------------------------
void libCNCC_gt_AIRSUPPORTCREATED_Init () {
    libCNCC_gt_AIRSUPPORTCREATED = TriggerCreate("libCNCC_gt_AIRSUPPORTCREATED_Func");
    TriggerAddEventUnitCreated(libCNCC_gt_AIRSUPPORTCREATED, null, null, null);
}

//--------------------------------------------------------------------------------------------------
// Trigger: AIRPOD CREATED
//--------------------------------------------------------------------------------------------------
bool libCNCC_gt_AIRPODCREATED_Func (bool testConds, bool runActions) {
    // Variable Declarations
    unit lv_airport;
    string lv_uD;
    string lv_uDTemp;

    // Automatic Variable Declarations
    string auto4A711C73_userType;
    int auto4A711C73_i;

    // Variable Initialization
    lv_airport = EventUnitCreatedUnit();

    // Conditions
    if (testConds) {
        if (!((UnitGetCustomValue(lv_airport, 5) == 0.0))) {
            return false;
        }

        if (!((UnitHasBehavior2(lv_airport, "AircraftAirportParkingAircraftTracking") == true))) {
            return false;
        }
    }

    // Actions
    if (!runActions) {
        return true;
    }

    auto4A711C73_userType = "Airports";
    auto4A711C73_i = 1;
    for ( ; auto4A711C73_i <= UserDataInstanceCount(auto4A711C73_userType) ; auto4A711C73_i += 1 ) {
        lv_uDTemp = UserDataInstance(auto4A711C73_userType, auto4A711C73_i);
        if ((UnitGetType(lv_airport) == UserDataGetUnit("Airports", lv_uDTemp, "Airport", 1))) {
            lv_uD = lv_uDTemp;
            break;
        }

    }
    if ((lv_uD == null)) {
        return true;
    }

    UnitSetCustomValue(lv_airport, 1, UserDataGetFixed("Airports", lv_uD, "SlotsOffsetX", 1));
    UnitSetCustomValue(lv_airport, 2, UserDataGetFixed("Airports", lv_uD, "SlotsOffsetY", 1));
    UnitSetCustomValue(lv_airport, 3, UserDataGetFixed("Airports", lv_uD, "SlotsHeight", 1));
    UnitSetCustomValue(lv_airport, 4, UserDataGetFixed("Airports", lv_uD, "SlotsFacing", 1));
    return true;
}

//--------------------------------------------------------------------------------------------------
void libCNCC_gt_AIRPODCREATED_Init () {
    libCNCC_gt_AIRPODCREATED = TriggerCreate("libCNCC_gt_AIRPODCREATED_Func");
    TriggerAddEventUnitCreated(libCNCC_gt_AIRPODCREATED, null, null, null);
}

//--------------------------------------------------------------------------------------------------
// Trigger: AIRPORTS Map INIT
//--------------------------------------------------------------------------------------------------
bool libCNCC_gt_AIRPORTSMapINIT_Func (bool testConds, bool runActions) {
    // Variable Declarations
    unit lv_airport;
    unit lv_slotUnit;
    string lv_slotUnitType;
    string lv_uD;
    int lv_slot;

    // Automatic Variable Declarations
    string auto6FBE374B_userType;
    int auto6FBE374B_i;
    unitgroup autoD4BA0719_g;
    int autoD4BA0719_u;
    int autoB0E088E1_ae;
    const int autoB0E088E1_ai = 1;

    // Variable Initialization

    // Actions
    if (!runActions) {
        return true;
    }

    auto6FBE374B_userType = "Airports";
    auto6FBE374B_i = 1;
    for ( ; auto6FBE374B_i <= UserDataInstanceCount(auto6FBE374B_userType) ; auto6FBE374B_i += 1 ) {
        lv_uD = UserDataInstance(auto6FBE374B_userType, auto6FBE374B_i);
        autoD4BA0719_g = UnitGroup(UserDataGetUnit("Airports", lv_uD, "Airport", 1), c_playerAny, RegionEntireMap(), UnitFilter(0, 0, (1 << c_targetFilterMissile), (1 << (c_targetFilterDead - 32)) | (1 << (c_targetFilterHidden - 32))), 0);
        autoD4BA0719_u = UnitGroupCount(autoD4BA0719_g, c_unitCountAll);
        for (;; autoD4BA0719_u -= 1) {
            lv_airport = UnitGroupUnitFromEnd(autoD4BA0719_g, autoD4BA0719_u);
            if (lv_airport == null) { break; }
            autoB0E088E1_ae = UserDataGetInt("Airports", lv_uD, "Slots", 1);
            lv_slot = 1;
            for ( ; ( (autoB0E088E1_ai >= 0 && lv_slot <= autoB0E088E1_ae) || (autoB0E088E1_ai < 0 && lv_slot >= autoB0E088E1_ae) ) ; lv_slot += autoB0E088E1_ai ) {
                lv_slotUnitType = UserDataGetUnit("Airports", lv_uD, "SlotUnit", lv_slot);
                if ((lv_slotUnitType == null)) {
                    lv_slotUnitType = "DockDummy";
                }

                libNtve_gf_CreateUnitsWithDefaultFacing(1, lv_slotUnitType, c_unitCreateIgnorePlacement, UnitGetOwner(lv_airport), UnitGetPosition(lv_airport));
                lv_slotUnit = UnitLastCreated();
                libCNCC_gf_AttachUnitModelToUnit(lv_slotUnit, lv_airport, ("Ref_Hardpoint 0" + IntToString(lv_slot)), 0.0, 0.0, 0.0, "SOp270");
                UnitSetCustomValue(lv_slotUnit, 1, UserDataGetFixed("Airports", lv_uD, "SlotsOffsetX", lv_slot));
                UnitSetCustomValue(lv_slotUnit, 2, UserDataGetFixed("Airports", lv_uD, "SlotsOffsetY", lv_slot));
                UnitSetCustomValue(lv_slotUnit, 3, UserDataGetFixed("Airports", lv_uD, "SlotsHeight", lv_slot));
                UnitSetCustomValue(lv_slotUnit, 4, UserDataGetFixed("Airports", lv_uD, "SlotsFacing", lv_slot));
                UnitBehaviorAdd(lv_slotUnit, "SuicideWithCaster", lv_airport, 1);
            }
        }
    }
    return true;
}

//--------------------------------------------------------------------------------------------------
void libCNCC_gt_AIRPORTSMapINIT_Init () {
    libCNCC_gt_AIRPORTSMapINIT = TriggerCreate("libCNCC_gt_AIRPORTSMapINIT_Func");
    TriggerAddEventMapInit(libCNCC_gt_AIRPORTSMapINIT);
}

//--------------------------------------------------------------------------------------------------
// Trigger: MoveCommandOverrideExecute
//--------------------------------------------------------------------------------------------------
bool libCNCC_gt_MoveCommandOverrideExecute_Func (bool testConds, bool runActions) {
    // Variable Declarations
    unit lv_airplane;
    unit lv_airport;

    // Automatic Variable Declarations
    // Variable Initialization
    lv_airplane = EventUnit();
    lv_airport = EventUnitTargetUnit();

    // Conditions
    if (testConds) {
        if (!((UnitAbilityExists(lv_airplane, "VS_ReturnToAirport") == true))) {
            return false;
        }
    }

    // Actions
    if (!runActions) {
        return true;
    }

    if ((UnitHasBehavior2(lv_airport, "AirSupport") == true)) {
        libCNCC_gf_SearchForAirportandLockit(lv_airplane, lv_airport, 15, false);
    }
    else {
        if ((UnitHasBehavior2(lv_airport, "AircraftAirportParkingAircraftTracking") == true)) {
            libCNCC_gf_TargetAirport(lv_airplane, lv_airport);
        }

    }
    return true;
}

//--------------------------------------------------------------------------------------------------
void libCNCC_gt_MoveCommandOverrideExecute_Init () {
    libCNCC_gt_MoveCommandOverrideExecute = TriggerCreate("libCNCC_gt_MoveCommandOverrideExecute_Func");
    TriggerAddEventUnitAbility(libCNCC_gt_MoveCommandOverrideExecute, null, AbilityCommand("CNCAirplaneMove", 0), c_unitAbilStageExecute, false);
}

//--------------------------------------------------------------------------------------------------
// Trigger: CREATED - Aircraft manufacturing completed
//--------------------------------------------------------------------------------------------------
bool libCNCC_gt_CREATEDAircraftmanufacturingcompleted_Func (bool testConds, bool runActions) {
    // Variable Declarations
    unit lv_airport;
    unit lv_airplane;

    // Automatic Variable Declarations
    // Variable Initialization
    lv_airport = EventUnitProgressUnit();
    lv_airplane = EventUnit();

    // Conditions
    if (testConds) {
        if (!((UnitAbilityExists(lv_airplane, "VS_ReturnToAirport") == true))) {
            return false;
        }
    }

    // Actions
    if (!runActions) {
        return true;
    }

    libCNCC_gf_SearchForAirportandLockit(lv_airplane, lv_airport, 15, true);
    return true;
}

//--------------------------------------------------------------------------------------------------
void libCNCC_gt_CREATEDAircraftmanufacturingcompleted_Init () {
    libCNCC_gt_CREATEDAircraftmanufacturingcompleted = TriggerCreate("libCNCC_gt_CREATEDAircraftmanufacturingcompleted_Func");
    TriggerAddEventUnitTrainProgress(libCNCC_gt_CREATEDAircraftmanufacturingcompleted, null, c_unitProgressStageComplete);
    TriggerAddEventUnitConstructProgress(libCNCC_gt_CREATEDAircraftmanufacturingcompleted, null, c_unitProgressStageComplete);
}

//--------------------------------------------------------------------------------------------------
// Trigger: Shadow Glide
//--------------------------------------------------------------------------------------------------
bool libCNCC_gt_ShadowGlide_Func (bool testConds, bool runActions) {
    // Variable Declarations
    unit lv_airport;
    unit lv_airplane;

    // Automatic Variable Declarations
    // Variable Initialization
    lv_airport = EventUnitProgressUnit();
    lv_airplane = EventUnit();

    // Conditions
    if (testConds) {
        if (!((UnitAbilityExists(lv_airplane, "CNCAirplaneMove") == false))) {
            return false;
        }
    }

    // Actions
    if (!runActions) {
        return true;
    }

    TriggerDebugOutput(1, StringExternal("Param/Value/lib_CNCC_C4F15889"), true);
    Wait(0.2, c_timeGame);
    UnitAbilityAdd(lv_airplane, "CNCAirplaneMove");
    UnitAbilityAdd(lv_airplane, "attack2");
    return true;
}

//--------------------------------------------------------------------------------------------------
void libCNCC_gt_ShadowGlide_Init () {
    libCNCC_gt_ShadowGlide = TriggerCreate("libCNCC_gt_ShadowGlide_Func");
    TriggerAddEventUnitBehaviorChange(libCNCC_gt_ShadowGlide, null, "VanguardIsCircling", c_unitBehaviorChangeIncrease);
}

//--------------------------------------------------------------------------------------------------
// Trigger: Shadow Landing
//--------------------------------------------------------------------------------------------------
bool libCNCC_gt_ShadowLanding_Func (bool testConds, bool runActions) {
    // Variable Declarations
    unit lv_airplane;

    // Automatic Variable Declarations
    // Variable Initialization
    lv_airplane = EventUnit();

    // Conditions
    if (testConds) {
        if (!((UnitAbilityExists(lv_airplane, "CNCAirplaneMove") == false))) {
            return false;
        }
    }

    // Actions
    if (!runActions) {
        return true;
    }

    Wait(0.05, c_timeGame);
    UnitAbilityRemove(lv_airplane, "CNCAirplaneMove");
    UnitAbilityRemove(lv_airplane, "attack2");
    UnitAbilityAdd(lv_airplane, "move");
    UnitAbilityAdd(lv_airplane, "attack");
    return true;
}

//--------------------------------------------------------------------------------------------------
void libCNCC_gt_ShadowLanding_Init () {
    libCNCC_gt_ShadowLanding = TriggerCreate("libCNCC_gt_ShadowLanding_Func");
    TriggerAddEventUnitAbility(libCNCC_gt_ShadowLanding, null, AbilityCommand("NodShadowLand", 0), c_unitAbilStageExecute, false);
}

//--------------------------------------------------------------------------------------------------
// Trigger: LANDING - Allied airfield landing
//--------------------------------------------------------------------------------------------------
bool libCNCC_gt_LANDINGAlliedairfieldlanding_Func (bool testConds, bool runActions) {
    int init_i;

    // Variable Declarations
    string lv_behavior;
    unit lv_airport;
    unit lv_airplane;
    point lv_landingpoint;
    point lv_lowerlandingpoint;
    point lv_upperlandingpoint;
    fixed lv_angledifference;
    fixed lv_turningtime;
    int lv_aircraftheading;
    string lv_airportcustomvaluestringtotal;
    string[5] lv_airportcustomvaluestringgroup;
    int lv_useslot;
    fixed lv_landingTime;
    string lv_dataTag;

    // Automatic Variable Declarations
    string auto8F19D4A3_val;

    // Variable Initialization
    lv_airplane = EventPlayerEffectUsedUnit(c_effectUnitCaster);
    lv_landingpoint = EventPlayerEffectUsedPoint(c_effectLocationTargetPoint);
    lv_airportcustomvaluestringtotal = "";
    for (init_i = 0; init_i <= 4; init_i += 1) {
        lv_airportcustomvaluestringgroup[init_i] = "";
    }
    lv_dataTag = ("TARGETAIRPORT" + IntToString(UnitGetTag(lv_airplane)));

    // Actions
    if (!runActions) {
        return true;
    }

    if ((DataTableValueExists(true, lv_dataTag) == false)) {
        libCNCC_gf_SearchForAirportandLockit(lv_airplane, null, 0, false);
        return true;
    }

    lv_airport = DataTableGetUnit(true, lv_dataTag);
    DataTableValueRemove(true, ("TARGETAIRPORT" + lv_dataTag));
    UnitBehaviorRemove(lv_airport, "LockedLandingPad", 1);
    if ((UnitHasBehavior2(lv_airport, "Docked") == true)) {
        libCNCC_gf_SearchForAirportandLockit(lv_airplane, lv_airport, 15, true);
        return true;
    }

    UnitBehaviorAdd(lv_airport, "Docked", lv_airplane, 1);
    UnitBehaviorAdd(lv_airplane, "AirportCurrentlyLanding", lv_airport, 1);
    lv_aircraftheading = FixedToInt(((-45.0 + UnitGetFacing(lv_airport)) + UnitGetCustomValue(lv_airport, 4)));
    UnitIssueOrder(lv_airplane, Order(AbilityCommand("ReloadingDummy", 0)), c_orderQueueAddToFront);
    UnitIssueOrder(lv_airplane, OrderTargetingPoint(AbilityCommand("CNCAirplaneMove", 0), lv_landingpoint), c_orderQueueAddToFront);
    Wait(0.5, c_timeGame);
    if (((UnitIsAlive(lv_airplane) == false) || (UnitIsAlive(lv_airport) == false))) {
        UnitBehaviorRemove(lv_airplane, "Airportcirclingprohibitedforaperiodoftime", 1);
        UnitBehaviorRemove(lv_airplane, "AirportCurrentlyLanding", 1);

    }
    else {
        UnitSetPosition(lv_airplane, lv_landingpoint, false);
        if ((UnitIsAlive(lv_airplane) == true) && (UnitIsAlive(lv_airport) == true)) {
            lv_angledifference = libCNCC_gf_Angledifferencebetweenunitandtargetpoint(lv_airplane, PointWithOffsetPolar(lv_landingpoint, 1.0, lv_aircraftheading));
            lv_turningtime = (lv_angledifference / UnitGetPropertyFixed(lv_airplane, c_unitPropTurnRate, c_unitPropCurrent));
            if ((lv_turningtime >= 1)) {
                lv_turningtime = 1.0;
            }

            UnitSetFacing(lv_airplane, lv_aircraftheading, lv_turningtime);
        }
        else {
            UnitBehaviorRemove(lv_airplane, "Airportcirclingprohibitedforaperiodoftime", 1);
            UnitBehaviorRemove(lv_airplane, "AirportCurrentlyLanding", 1);
            UnitBehaviorRemove(lv_airport, "Docked", 1);

        }
        if ((UnitIsAlive(lv_airplane) == true) && (UnitIsAlive(lv_airport) == true)) {
            UnitBehaviorAdd(lv_airplane, "AirportNousefortakeoff", lv_airplane, 1);
            auto8F19D4A3_val = UnitGetType(lv_airplane);
            if (auto8F19D4A3_val == "SovietBeaver") {
                lv_landingTime = 2.0;
            }
            else if (auto8F19D4A3_val == "ChinaH20StealthBomber") {
                lv_landingTime = 2.0;
            }
            else if (auto8F19D4A3_val == "AlliedCenturyBomber") {
                lv_landingTime = 1.6;
            }
            else {
                lv_landingTime = 0.75;
            }
            UnitSetHeight(lv_airplane, (UnitGetHeight(lv_airport) + UnitGetCustomValue(lv_airport, 3)), lv_landingTime);
            UnitBehaviorRemove(lv_airplane, "AirportCurrentlyLanding", 1);
            UnitBehaviorSetDuration(lv_airplane, "AirportNousefortakeoff", lv_landingTime);
            UnitBehaviorAdd(lv_airplane, "Airportlanded", lv_airplane, 1);
            UnitBehaviorAdd(lv_airplane, "Aircraftreversesurveillanceoftheairport", lv_airplane, 1);
            UnitCreateEffectUnit(lv_airport, "CNCTrackairporttoaircraft", lv_airplane);
            UnitBehaviorAdd(lv_airplane, "Notifyairportaftertakeofforexplosion", lv_airplane, 1);
            UnitBehaviorRemove(lv_airplane, "Airportslotassigned", 1);
            Wait(lv_landingTime, c_timeGame);
            UnitSetHeight(lv_airplane, (UnitGetHeight(lv_airport) + UnitGetCustomValue(lv_airport, 3)), 0.0);
        }
        else {
            UnitBehaviorRemove(lv_airplane, "AirportCurrentlyLanding", 1);
            UnitBehaviorRemove(lv_airplane, "Airportcirclingprohibitedforaperiodoftime", 1);
            UnitBehaviorRemove(lv_airport, "Docked", 1);

        }
    }
    return true;
}

//--------------------------------------------------------------------------------------------------
void libCNCC_gt_LANDINGAlliedairfieldlanding_Init () {
    libCNCC_gt_LANDINGAlliedairfieldlanding = TriggerCreate("libCNCC_gt_LANDINGAlliedairfieldlanding_Func");
    TriggerAddEventPlayerEffectUsed(libCNCC_gt_LANDINGAlliedairfieldlanding, c_playerAny, "DockedDummy");
}

//--------------------------------------------------------------------------------------------------
// Trigger: Aircraft restoration slot
//--------------------------------------------------------------------------------------------------
bool libCNCC_gt_Aircraftrestorationslot_Func (bool testConds, bool runActions) {
    // Variable Declarations
    unit lv_airport;
    unit lv_airplane;

    // Automatic Variable Declarations
    // Variable Initialization
    lv_airport = EventPlayerEffectUsedUnit(c_effectUnitTarget);
    lv_airplane = EventPlayerEffectUsedUnit(c_effectUnitCaster);

    // Actions
    if (!runActions) {
        return true;
    }

    UnitBehaviorRemove(lv_airport, "Docked", 1);
    return true;
}

//--------------------------------------------------------------------------------------------------
void libCNCC_gt_Aircraftrestorationslot_Init () {
    libCNCC_gt_Aircraftrestorationslot = TriggerCreate("libCNCC_gt_Aircraftrestorationslot_Func");
    TriggerAddEventPlayerEffectUsed(libCNCC_gt_Aircraftrestorationslot, c_playerAny, "Vesteffectwhenaircraftdiesortakesoff");
}

//--------------------------------------------------------------------------------------------------
// Trigger: TAKEOFF - The effect of the plane after takeoff
//--------------------------------------------------------------------------------------------------
bool libCNCC_gt_TAKEOFFTheeffectoftheplaneaftertakeoff_Func (bool testConds, bool runActions) {
    // Variable Declarations
    unit lv_airport;
    unit lv_airplane;
    fixed lv_waitingtime;

    // Automatic Variable Declarations
    // Variable Initialization
    lv_airplane = EventPlayerEffectUsedUnit(c_effectUnitCaster);

    // Actions
    if (!runActions) {
        return true;
    }

    libCNCC_gf_Theplanetakesoff(lv_airplane);
    return true;
}

//--------------------------------------------------------------------------------------------------
void libCNCC_gt_TAKEOFFTheeffectoftheplaneaftertakeoff_Init () {
    libCNCC_gt_TAKEOFFTheeffectoftheplaneaftertakeoff = TriggerCreate("libCNCC_gt_TAKEOFFTheeffectoftheplaneaftertakeoff_Func");
    TriggerAddEventPlayerEffectUsed(libCNCC_gt_TAKEOFFTheeffectoftheplaneaftertakeoff, c_playerAny, "PlaneTakesOffC");
}

//--------------------------------------------------------------------------------------------------
// Trigger: TAKEOFF ATTACK
//--------------------------------------------------------------------------------------------------
bool libCNCC_gt_TAKEOFFATTACK_Func (bool testConds, bool runActions) {
    // Variable Declarations
    unit lv_airplane;
    fixed lv_waitingtime;

    // Automatic Variable Declarations
    // Variable Initialization
    lv_airplane = EventUnit();

    // Conditions
    if (testConds) {
        if (!((UnitHasBehavior2(lv_airplane, "Notifyairportaftertakeofforexplosion") == true))) {
            return false;
        }
    }

    // Actions
    if (!runActions) {
        return true;
    }

    UnitIssueOrder(lv_airplane, Order(AbilityCommand("CNCAirportPlanetakingoff", 0)), c_orderQueueAddToFront);
    return true;
}

//--------------------------------------------------------------------------------------------------
void libCNCC_gt_TAKEOFFATTACK_Init () {
    libCNCC_gt_TAKEOFFATTACK = TriggerCreate("libCNCC_gt_TAKEOFFATTACK_Func");
    TriggerAddEventUnitAbility(libCNCC_gt_TAKEOFFATTACK, null, AbilityCommand("attack2", 0), c_unitAbilStageExecute, false);
    TriggerAddEventUnitAbility(libCNCC_gt_TAKEOFFATTACK, null, AbilityCommand("CNCAirplaneMove", 0), c_unitAbilStageExecute, false);
    TriggerAddEventUnitAbility(libCNCC_gt_TAKEOFFATTACK, null, AbilityCommand("CNCAirplaneMove", 1), c_unitAbilStageExecute, false);
    TriggerAddEventUnitAbility(libCNCC_gt_TAKEOFFATTACK, null, AbilityCommand("CNCAirplaneMove", 3), c_unitAbilStageExecute, false);
}

//--------------------------------------------------------------------------------------------------
// Trigger: NO AMMO - RETURN
//--------------------------------------------------------------------------------------------------
bool libCNCC_gt_NOAMMORETURN_Func (bool testConds, bool runActions) {
    // Variable Declarations
    unit lv_airplane;

    // Automatic Variable Declarations
    // Variable Initialization
    lv_airplane = EventPlayerEffectUsedUnit(c_effectUnitCaster);

    // Actions
    if (!runActions) {
        return true;
    }

    TriggerDebugOutput(1, StringExternal("Param/Value/lib_CNCC_2F42BC7B"), true);
    if ((UnitGetCustomValue(lv_airplane, 11) == 0.0)) {
        libCNCC_gf_SearchForAirportandLockit(lv_airplane, null, 0, false);
    }

    return true;
}

//--------------------------------------------------------------------------------------------------
void libCNCC_gt_NOAMMORETURN_Init () {
    libCNCC_gt_NOAMMORETURN = TriggerCreate("libCNCC_gt_NOAMMORETURN_Func");
    TriggerAddEventPlayerEffectUsed(libCNCC_gt_NOAMMORETURN, c_playerAny, "AirReturnLackOfAmmoDummy");
}

//--------------------------------------------------------------------------------------------------
// Trigger: NO AMMO - Attack Complete
//--------------------------------------------------------------------------------------------------
bool libCNCC_gt_NOAMMOAttackComplete_Func (bool testConds, bool runActions) {
    // Variable Declarations
    unit lv_airplane;

    // Automatic Variable Declarations
    // Variable Initialization
    lv_airplane = EventUnit();

    // Actions
    if (!runActions) {
        return true;
    }

    TriggerDebugOutput(1, StringExternal("Param/Value/lib_CNCC_8779543B"), true);
    if ((ValidatorExecute("CasterHasEnergy22", lv_airplane, lv_airplane) == 0) && (UnitGetCustomValue(lv_airplane, 11) == 0.0)) {
        libCNCC_gf_SearchForAirportandLockit(lv_airplane, null, 0, false);
    }

    return true;
}

//--------------------------------------------------------------------------------------------------
void libCNCC_gt_NOAMMOAttackComplete_Init () {
    libCNCC_gt_NOAMMOAttackComplete = TriggerCreate("libCNCC_gt_NOAMMOAttackComplete_Func");
    TriggerAddEventUnitAbility(libCNCC_gt_NOAMMOAttackComplete, null, AbilityCommand("attack2", 0), c_unitAbilStageComplete, false);
}

//--------------------------------------------------------------------------------------------------
// Trigger: ENABLE AUTO-RETURN
//--------------------------------------------------------------------------------------------------
bool libCNCC_gt_ENABLEAUTORETURN_Func (bool testConds, bool runActions) {
    // Variable Declarations
    unit lv_airplane;

    // Automatic Variable Declarations
    // Variable Initialization
    lv_airplane = EventUnit();

    // Actions
    if (!runActions) {
        return true;
    }

    UnitSetCustomValue(lv_airplane, 11, 0.0);
    if ((ValidatorExecute("CasterHasEnergy22", lv_airplane, lv_airplane) == 0)) {
        libCNCC_gf_SearchForAirportandLockit(lv_airplane, null, 0, false);
    }

    return true;
}

//--------------------------------------------------------------------------------------------------
void libCNCC_gt_ENABLEAUTORETURN_Init () {
    libCNCC_gt_ENABLEAUTORETURN = TriggerCreate("libCNCC_gt_ENABLEAUTORETURN_Func");
    TriggerAddEventUnitAbilityAutoCastChange(libCNCC_gt_ENABLEAUTORETURN, null, AbilityCommand("CNCReturnToTheAirport", 0), c_unitAbilAutoCastChangeOn, false);
}

//--------------------------------------------------------------------------------------------------
// Trigger: DISABLE AUTO-RETURN
//--------------------------------------------------------------------------------------------------
bool libCNCC_gt_DISABLEAUTORETURN_Func (bool testConds, bool runActions) {
    // Variable Declarations
    unit lv_airplane;

    // Automatic Variable Declarations
    // Variable Initialization
    lv_airplane = EventUnit();

    // Actions
    if (!runActions) {
        return true;
    }

    UnitSetCustomValue(lv_airplane, 11, 1.0);
    return true;
}

//--------------------------------------------------------------------------------------------------
void libCNCC_gt_DISABLEAUTORETURN_Init () {
    libCNCC_gt_DISABLEAUTORETURN = TriggerCreate("libCNCC_gt_DISABLEAUTORETURN_Func");
    TriggerAddEventUnitAbilityAutoCastChange(libCNCC_gt_DISABLEAUTORETURN, null, AbilityCommand("CNCReturnToTheAirport", 0), c_unitAbilAutoCastChangeOff, false);
}

//--------------------------------------------------------------------------------------------------
// Trigger: DOCKED CANCELLED - remove lock
//--------------------------------------------------------------------------------------------------
bool libCNCC_gt_DOCKEDCANCELLEDremovelock_Func (bool testConds, bool runActions) {
    // Variable Declarations
    unit lv_airplane;
    unit lv_airport;
    string lv_dataTag;

    // Automatic Variable Declarations
    // Variable Initialization
    lv_airplane = EventUnit();
    lv_dataTag = ("TARGETAIRPORT" + IntToString(UnitGetTag(lv_airplane)));

    // Conditions
    if (testConds) {
        if (!((DataTableValueExists(true, lv_dataTag) == true))) {
            return false;
        }
    }

    // Actions
    if (!runActions) {
        return true;
    }

    lv_airport = DataTableGetUnit(true, lv_dataTag);
    DataTableValueRemove(true, ("TARGETAIRPORT" + lv_dataTag));
    UnitBehaviorRemove(lv_airport, "LockedLandingPad", 1);
    return true;
}

//--------------------------------------------------------------------------------------------------
void libCNCC_gt_DOCKEDCANCELLEDremovelock_Init () {
    libCNCC_gt_DOCKEDCANCELLEDremovelock = TriggerCreate("libCNCC_gt_DOCKEDCANCELLEDremovelock_Func");
    TriggerAddEventUnitAbility(libCNCC_gt_DOCKEDCANCELLEDremovelock, null, AbilityCommand("VS_ReturnToAirport", 0), c_unitAbilStageCancel, false);
}

//--------------------------------------------------------------------------------------------------
// Trigger: ABILITY - RETURN TO AIRPORT GLOBAL
//--------------------------------------------------------------------------------------------------
bool libCNCC_gt_ABILITYRETURNTOAIRPORTGLOBAL_Func (bool testConds, bool runActions) {
    // Automatic Variable Declarations
    // Actions
    if (!runActions) {
        return true;
    }

    libCNCC_gf_SearchForAirportandLockit(EventPlayerEffectUsedUnit(c_effectUnitCaster), null, 0, false);
    return true;
}

//--------------------------------------------------------------------------------------------------
void libCNCC_gt_ABILITYRETURNTOAIRPORTGLOBAL_Init () {
    libCNCC_gt_ABILITYRETURNTOAIRPORTGLOBAL = TriggerCreate("libCNCC_gt_ABILITYRETURNTOAIRPORTGLOBAL_Func");
    TriggerAddEventPlayerEffectUsed(libCNCC_gt_ABILITYRETURNTOAIRPORTGLOBAL, c_playerAny, "AirReturn");
}

//--------------------------------------------------------------------------------------------------
// Trigger: ABILITY - RETURN TO AIRPORT TARGET
//--------------------------------------------------------------------------------------------------
bool libCNCC_gt_ABILITYRETURNTOAIRPORTTARGET_Func (bool testConds, bool runActions) {
    // Automatic Variable Declarations
    // Actions
    if (!runActions) {
        return true;
    }

    libCNCC_gf_TargetAirport(EventPlayerEffectUsedUnit(c_effectUnitCaster), EventPlayerEffectUsedUnit(c_effectUnitTarget));
    return true;
}

//--------------------------------------------------------------------------------------------------
void libCNCC_gt_ABILITYRETURNTOAIRPORTTARGET_Init () {
    libCNCC_gt_ABILITYRETURNTOAIRPORTTARGET = TriggerCreate("libCNCC_gt_ABILITYRETURNTOAIRPORTTARGET_Func");
    TriggerAddEventPlayerEffectUsed(libCNCC_gt_ABILITYRETURNTOAIRPORTTARGET, c_playerAny, "DockedDummy2");
}

//--------------------------------------------------------------------------------------------------
// Trigger: Pioneer mobile reset cd
//--------------------------------------------------------------------------------------------------
bool libCNCC_gt_Pioneermobileresetcd_Func (bool testConds, bool runActions) {
    // Variable Declarations
    unit lv_attackingunit;
    fixed lv_angle;
    point lv_centerpoint;
    point lv_movetargetpoint;
    fixed lv_angledifference;
    fixed lv_timerequired;
    int lv_requirednumberoftimes;
    bool lv_isitleft;
    fixed lv_approximatearcdistance;

    // Automatic Variable Declarations
    // Variable Initialization

    // Actions
    if (!runActions) {
        return true;
    }

    lv_attackingunit = EventUnit();
    lv_angledifference = libCNCC_gf_Angledifferencebetweenunitandtargetpoint(lv_attackingunit, EventUnitTargetPoint());
    if ((lv_angledifference > 45.0)) {
        UnitBehaviorAdd(lv_attackingunit, "VanguardCannotUseMovementSkills", lv_attackingunit, 1);
        UnitBehaviorSetDuration(lv_attackingunit, "VanguardCannotUseMovementSkills", 0.5);
    }

    return true;
}

//--------------------------------------------------------------------------------------------------
void libCNCC_gt_Pioneermobileresetcd_Init () {
    libCNCC_gt_Pioneermobileresetcd = TriggerCreate("libCNCC_gt_Pioneermobileresetcd_Func");
    TriggerAddEventUnitAbility(libCNCC_gt_Pioneermobileresetcd, null, AbilityCommand("CNCAirplaneMove", 0), c_unitAbilStageExecute, false);
}

//--------------------------------------------------------------------------------------------------
// Trigger: Vanguard Attack Surround
//--------------------------------------------------------------------------------------------------
bool libCNCC_gt_VanguardAttackSurround_Func (bool testConds, bool runActions) {
    // Variable Declarations
    unit lv_attackingunit;
    unit lv_attackedunit;
    point lv_movetargetpoint;
    fixed lv_angle;
    point lv_centerpoint;
    int lv_numberofdelays;

    // Automatic Variable Declarations
    const int autoC2FB55BE_n = 80;
    int autoC2FB55BE_i;
    int auto95090F41_n;
    int auto95090F41_i;

    // Variable Initialization
    lv_numberofdelays = 80;

    // Conditions
    if (testConds) {
        if (!((UnitBehaviorCount(EventPlayerEffectUsedUnit(c_effectUnitCaster), "VanguardCannotUseMovementSkills") == 0))) {
            return false;
        }
    }

    // Actions
    if (!runActions) {
        return true;
    }

    lv_attackingunit = EventPlayerEffectUsedUnit(c_effectUnitCaster);
    lv_attackedunit = EventPlayerEffectUsedUnit(c_effectUnitTarget);
    lv_attackingunit = EventPlayerEffectUsedUnit(c_effectUnitCaster);
    lv_angle = AngleBetweenPoints(UnitGetPosition(lv_attackingunit), UnitGetPosition(lv_attackedunit));
    lv_centerpoint = PointWithOffsetPolar(UnitGetPosition(lv_attackingunit), 0.1, lv_angle);
    Wait(0.1, c_timeGame);
    for (autoC2FB55BE_i = 1; autoC2FB55BE_i <= autoC2FB55BE_n; autoC2FB55BE_i += 1) {
        if (((UnitIsAlive(lv_attackingunit) == true) && (UnitIsAlive(lv_attackedunit) == true) && (UnitBehaviorCount(lv_attackingunit, "DisablestopautoandattackinVanguardmovementcommand") == 0))) {
            lv_numberofdelays -= 1;
            lv_angle = AngleBetweenPoints(UnitGetPosition(lv_attackingunit), UnitGetPosition(lv_attackedunit));
            UnitBehaviorAdd(lv_attackingunit, "PioneerDisablesStoppingAutoCirclingA", lv_attackingunit, 1);
            UnitBehaviorSetDuration(lv_attackingunit, "PioneerDisablesStoppingAutoCirclingA", 0.125);
            lv_movetargetpoint = libCNCC_gf_SurroundAttackAcquisitionPoint(lv_attackingunit, UnitGetPosition(lv_attackedunit));
            libCNCC_gf_Continuemovingtotargetpoint(lv_attackingunit, lv_movetargetpoint, 0.2);
            Wait(0.0625, c_timeGame);
        }
        else {
            if (((UnitIsAlive(lv_attackingunit) == true) && (UnitIsAlive(lv_attackedunit) == false) && (UnitBehaviorCount(lv_attackingunit, "DisablestopautoandattackinVanguardmovementcommand") == 0))) {
                lv_centerpoint = PointWithOffsetPolar(UnitGetPosition(lv_attackingunit), 6.0, lv_angle);
                lv_numberofdelays -= 3;
                auto95090F41_n = lv_numberofdelays;
                for (auto95090F41_i = 1; auto95090F41_i <= auto95090F41_n; auto95090F41_i += 1) {
                    if ((UnitBehaviorCount(lv_attackingunit, "DisablestopautoandattackinVanguardmovementcommand") == 0)) {
                        libCNCC_gf_Cruiseoncewhendestroyingatarget(lv_attackingunit, lv_centerpoint);
                        Wait(0.0625, c_timeGame);
                    }
                    else {
                        break;
                    }
                }
                break;
            }
            else {
                UnitBehaviorRemove(lv_attackingunit, "PioneerDisablesStoppingAutoCirclingA", 1);
                break;
            }
        }
    }
    return true;
}

//--------------------------------------------------------------------------------------------------
void libCNCC_gt_VanguardAttackSurround_Init () {
    libCNCC_gt_VanguardAttackSurround = TriggerCreate("libCNCC_gt_VanguardAttackSurround_Func");
    TriggerAddEventPlayerEffectUsed(libCNCC_gt_VanguardAttackSurround, c_playerAny, "Vanguardsurroundingvesteffect");
}

//--------------------------------------------------------------------------------------------------
// Trigger: CIRCLE - Allied fighter planes automatically circle when stopped
//--------------------------------------------------------------------------------------------------
bool libCNCC_gt_CIRCLEAlliedfighterplanesautomaticallycirclewhenstopped_Func (bool testConds, bool runActions) {
    // Variable Declarations
    unit lv_attackingunit;
    fixed lv_angle;
    point lv_centerpoint;
    point lv_movetargetpoint;

    // Automatic Variable Declarations
    // Variable Initialization

    // Conditions
    if (testConds) {
        if (!(((UnitBehaviorCount(EventPlayerEffectUsedUnit(c_effectUnitCaster), "PioneerDisablesStoppingAutoCirclingA") == 0) && (UnitBehaviorCount(EventPlayerEffectUsedUnit(c_effectUnitCaster), "DisablestopautoandattackinVanguardmovementcommand") == 0)))) {
            return false;
        }
    }

    // Actions
    if (!runActions) {
        return true;
    }

    lv_attackingunit = EventPlayerEffectUsedUnit(c_effectUnitCaster);
    lv_angle = (UnitGetFacing(lv_attackingunit) - 150.0);
    lv_centerpoint = PointWithOffsetPolar(UnitGetPosition(lv_attackingunit), 0.1, lv_angle);
    while (true) {
        if (((UnitIsAlive(lv_attackingunit) == true) && (UnitBehaviorCount(lv_attackingunit, "PioneerDisablesStoppingAutoCirclingA") == 0) && (UnitBehaviorCount(lv_attackingunit, "DisablestopautoandattackinVanguardmovementcommand") == 0) && (UnitBehaviorCount(lv_attackingunit, "StopautocirclingdisabledinPeacekeeperbomberattackcommand") == 0) && (UnitOrderCount(lv_attackingunit) == 0))) {
            libCNCC_gf_OnecruisewhilestationaryAlliedfighteraircraft(lv_attackingunit, lv_centerpoint);
            Wait(0.0625, c_timeGame);
        }
        else {
            break;
        }
    }
    return true;
}

//--------------------------------------------------------------------------------------------------
void libCNCC_gt_CIRCLEAlliedfighterplanesautomaticallycirclewhenstopped_Init () {
    libCNCC_gt_CIRCLEAlliedfighterplanesautomaticallycirclewhenstopped = TriggerCreate("libCNCC_gt_CIRCLEAlliedfighterplanesautomaticallycirclewhenstopped_Func");
    TriggerAddEventPlayerEffectUsed(libCNCC_gt_CIRCLEAlliedfighterplanesautomaticallycirclewhenstopped, c_playerAny, "Thehoveringvesteffectwhenthevanguardisstopped");
}

void libCNCC_InitTriggers () {
    libCNCC_gt_WatchUnitCreation_Init();
    libCNCC_gt_WatchUnitOwner_Init();
    libCNCC_gt_WatchUnitDeath_Init();
    libCNCC_gt_WatchUnitBehaviors_Init();
    libCNCC_gt_RecalculateBeacons_Init();
    libCNCC_gt_InitBeaconsButton_Init();
    libCNCC_gt_BeaconsButtonUsed_Init();
    libCNCC_gt_ProductionUI_Init();
    libCNCC_gt_Unitupgradespecialeffects_Init();
    libCNCC_gt_Unitsgainexperiencebyrisingstars_Init();
    libCNCC_gt_Maintenancebeeheightadjustment_Init();
    libCNCC_gt_Maintenancebeeheightrestored_Init();
    libCNCC_gt_AIRSUPPORTCREATED_Init();
    libCNCC_gt_AIRPODCREATED_Init();
    libCNCC_gt_AIRPORTSMapINIT_Init();
    libCNCC_gt_MoveCommandOverrideExecute_Init();
    libCNCC_gt_CREATEDAircraftmanufacturingcompleted_Init();
    libCNCC_gt_ShadowGlide_Init();
    libCNCC_gt_ShadowLanding_Init();
    libCNCC_gt_LANDINGAlliedairfieldlanding_Init();
    libCNCC_gt_Aircraftrestorationslot_Init();
    libCNCC_gt_TAKEOFFTheeffectoftheplaneaftertakeoff_Init();
    libCNCC_gt_TAKEOFFATTACK_Init();
    libCNCC_gt_NOAMMORETURN_Init();
    libCNCC_gt_NOAMMOAttackComplete_Init();
    libCNCC_gt_ENABLEAUTORETURN_Init();
    libCNCC_gt_DISABLEAUTORETURN_Init();
    libCNCC_gt_DOCKEDCANCELLEDremovelock_Init();
    libCNCC_gt_ABILITYRETURNTOAIRPORTGLOBAL_Init();
    libCNCC_gt_ABILITYRETURNTOAIRPORTTARGET_Init();
    libCNCC_gt_Pioneermobileresetcd_Init();
    libCNCC_gt_VanguardAttackSurround_Init();
    libCNCC_gt_CIRCLEAlliedfighterplanesautomaticallycirclewhenstopped_Init();
}

//--------------------------------------------------------------------------------------------------
// Library Initialization
//--------------------------------------------------------------------------------------------------
bool libCNCC_InitLib_completed = false;

void libCNCC_InitLib () {
    if (libCNCC_InitLib_completed) {
        return;
    }

    libCNCC_InitLib_completed = true;

    libCNCC_InitLibraries();
    libCNCC_InitVariables();
    libCNCC_InitTriggers();
}

